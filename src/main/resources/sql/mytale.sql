-- MySQL dump 10.13  Distrib 5.5.58, for debian-linux-gnu (x86_64)
--
-- Host: localhost    Database: tale
-- ------------------------------------------------------
-- Server version	5.5.58-0+deb8u1

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `t_attach`
--

DROP TABLE IF EXISTS `t_attach`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `t_attach` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `fname` varchar(100) NOT NULL DEFAULT '',
  `ftype` varchar(50) DEFAULT '',
  `fkey` varchar(100) NOT NULL DEFAULT '',
  `author_id` int(10) DEFAULT NULL,
  `created` int(10) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=72 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_attach`
--

LOCK TABLES `t_attach` WRITE;
/*!40000 ALTER TABLE `t_attach` DISABLE KEYS */;
INSERT INTO `t_attach` VALUES (2,'1-min.jpg','image','/upload/2017/12/o78ohfc63ehsoohd4ns46mieeq.jpg',1,1514361191),(3,'2-min.jpg','image','/upload/2017/12/uc4rg7uigajasrch1uga1715gu.jpg',1,1514361237),(6,'lintcode.png','image','/upload/2017/12/v3gfpspijuijvospgoisksnd2d.png',1,1514641349),(7,'mooc.png','image','/upload/2017/12/ppak9tnk18gbarvgg4kpl6oa6g.png',1,1514641483),(8,'answer.jpg','image','/upload/2018/01/0k7j9agplagmvoqbqblerod8u8.jpg',1,1515135275),(9,'views.jpg','image','/upload/2018/01/3ufv0ssvmqh9fo7mq4l70e1ra8.jpg',1,1515135275),(10,'books2.png','image','/upload/2018/01/v6udi0e0n2j1rrcdeu266tq2kn.png',1,1515135620),(11,'books1.png','image','/upload/2018/01/oc3c6qdupehgsrivl7u3flbr2b.png',1,1515135636),(12,'DownloadELK.png','image','/upload/2018/01/3k8lm06kuego1phcrgbl2psaf8.png',1,1516498484),(13,'bing.png','image','/upload/2018/01/34avark8tsif5r1l3mp087tfts.png',1,1516498496),(14,'ELK官网.png','image','/upload/2018/01/p92m1qiufegc6o895jp9imr9t7.png',1,1516498503),(15,'KCountries.png','image','/upload/2018/01/53hsef72iqg4rrvuluvfole81r.png',1,1516498507),(16,'KDiscover.png','image','/upload/2018/01/rbqa2f42e2gklq0lhb4d0739h1.png',1,1516498510),(17,'KibanaTimeLion.png','image','/upload/2018/01/o0cnk6de76hdmqj4pk03gjlj5d.png',1,1516498514),(18,'Kibana界面.png','image','/upload/2018/01/1pfcck64kahhcrbo9v7j741a2s.png',1,1516498516),(19,'KManage.png','image','/upload/2018/01/774vkg2u3qjjdou52m5o025fju.png',1,1516498521),(20,'KVis.png','image','/upload/2018/01/0n4odd8dvkhl7pc4ckt98crfvd.png',1,1516498523),(21,'Logstash启动.png','image','/upload/2018/01/t9sh0ip0nkj1cp1l83mg67nes2.png',1,1516498536),(22,'oneData.png','image','/upload/2018/01/7dp8i40s5qjfgof5ia8qqki440.png',1,1516498543),(23,'ciyun.png','image','/upload/2018/01/68thdlg93sjj9rpdmv86a7vm5l.png',1,1516498951),(24,'包结构.png','image','/upload/2018/02/ppua1psoomjh8qbut2avp1r5ia.png',1,1517649458),(25,'出错信息文件.png','image','/upload/2018/02/46kc5fo2d0jslo49p16774buj5.png',1,1517652669),(26,'用户入口.png','image','/upload/2018/02/oe4g9i8lsgh2irj879njarivq6.png',1,1517652669),(27,'用户控制.png','image','/upload/2018/02/5qk57255ughv8pf6jfspejh4rv.png',1,1517652669),(28,'拦截器.png','image','/upload/2018/02/rrs4jue9r8janpec3o8hnsspd0.png',1,1517653241),(29,'图片访问.png','image','/upload/2018/02/3r4c96oqdeg4fp8mg92ikcra64.png',1,1517653983),(30,'图片存储.png','image','/upload/2018/02/4qhkoj5rhmjtko7u7i7tflclij.png',1,1517653983),(31,'转换器.png','image','/upload/2018/02/6fofg2a9q4ivpqt8v8ld526cgl.png',1,1517654512),(33,'849589-20180402133438219-1946132192.png','image','/upload/2018/05/uhhr3ei678i5uo3mlea51mp3ev.png',1,1526092634),(34,'20160428153947383.png','image','/upload/2018/05/rekgrv9qdigfhqm0ei6j1ulrou.png',1,1526100121),(35,'7-4-2.jpg','image','/upload/2018/05/4jmcha5650jk1rkl83edni7ns1.jpg',1,1526100729),(36,'7-4-3.jpg','image','/upload/2018/05/q6qpdlrkaehlnrqhum30bacrrr.jpg',1,1526100872),(37,'7-4-6.jpg','image','/upload/2018/05/7pcgojj3d0gkpr50t1a48ssqe7.jpg',1,1526101322),(38,'7-4-7.jpg','image','/upload/2018/05/tjih3b1o7sjdmrg828jvvkgptf.jpg',1,1526101564),(39,'7-4-10.jpg','image','/upload/2018/05/7j4m382bs2hlloh5fha476qs7h.jpg',1,1526101871),(40,'252248450292152.png','image','/upload/2018/05/3e618nomf0ggprqppm3fe15jv4.png',1,1526103764),(41,'270024368439888.png','image','/upload/2018/05/51p6trc5l2hedralemrqbmcg9g.png',1,1526104000),(42,'270024403113529.png','image','/upload/2018/05/5hqe87h636g4vqh2khfebncbbk.png',1,1526104092),(44,'290047034539184.png','image','/upload/2018/05/rbcq8o2bf8gl1qe8k6nrcavrvh.png',1,1526104432),(45,'290050048129679.png','image','/upload/2018/05/4l55dn2d1ih1uoec2spe43bf3a.png',1,1526104437),(46,'class33-01.jpg','image','/upload/2018/05/23n2i21dq0g7crcu3hsr6uvaps.jpg',1,1526106016),(47,'151758066106515.png','image','/upload/2018/05/ul9p61c8u2h5sp3bkb2ce6bet4.png',1,1526106501),(48,'151758437356873.png','image','/upload/2018/05/ukooi2devkj82rb3p57rcj2tni.png',1,1526106685),(49,'222.png','image','/upload/2018/05/65jbm746r6ge3qpm2b228hsdam.png',1,1526106813),(50,'333.png','image','/upload/2018/05/2d1fpu7pvmghbqjm6lfovp4ngu.png',1,1526106813),(59,'2.jpg','image','/upload/2018/06/3ge1p9rjh6g71rdqimomcstrbv.jpg',1,1527995891),(60,'1.jpg','image','/upload/2018/06/rp3ufo9o24jb0og42uck5soqs3.jpg',1,1527995892),(61,'4.jpg','image','/upload/2018/06/2b9ff94g3iiqsp3vf6l8t7ni1q.jpg',1,1527995947),(63,'3.jpg','image','/upload/2018/06/smanl83ctcgg1ov87fccvj4veu.jpg',1,1527995975),(64,'5.jpg','image','/upload/2018/06/06n6h2vla0hcept871vfquu6tt.jpg',1,1527996180),(65,'6.jpg','image','/upload/2018/06/40irrlgi5iifapi11p1aeem3o5.jpg',1,1527996198),(66,'8.jpg','image','/upload/2018/06/4eamrsese0hoirbboh4hahlfm3.jpg',1,1527996262),(67,'7.jpg','image','/upload/2018/06/10c7mathkeipgrojp8ktmlpsik.jpg',1,1527996285),(68,'10.jpg','image','/upload/2018/06/020jn9rnaij9epr7a63ie7sa97.jpg',1,1527996306),(69,'9.jpg','image','/upload/2018/06/pdqvr1btgsjd1o1eoppm9tf0h8.jpg',1,1527996308),(71,'捕获.PNG','image','/upload/2018/06/6m24im70aohajprtg1g3s8c08v.PNG',1,1530277271);
/*!40000 ALTER TABLE `t_attach` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_comments`
--

DROP TABLE IF EXISTS `t_comments`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `t_comments` (
  `coid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `cid` int(10) unsigned DEFAULT '0',
  `created` int(10) unsigned DEFAULT '0',
  `author` varchar(200) DEFAULT NULL,
  `author_id` int(10) unsigned DEFAULT '0',
  `owner_id` int(10) unsigned DEFAULT '0',
  `mail` varchar(200) DEFAULT NULL,
  `url` varchar(200) DEFAULT NULL,
  `ip` varchar(64) DEFAULT NULL,
  `agent` varchar(200) DEFAULT NULL,
  `content` text,
  `type` varchar(16) DEFAULT 'comment',
  `status` varchar(16) DEFAULT 'approved',
  `parent` int(10) unsigned DEFAULT '0',
  PRIMARY KEY (`coid`),
  KEY `cid` (`cid`),
  KEY `created` (`created`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_comments`
--

LOCK TABLES `t_comments` WRITE;
/*!40000 ALTER TABLE `t_comments` DISABLE KEYS */;
/*!40000 ALTER TABLE `t_comments` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_contents`
--

DROP TABLE IF EXISTS `t_contents`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `t_contents` (
  `cid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `title` varchar(200) DEFAULT NULL,
  `slug` varchar(200) DEFAULT NULL,
  `created` int(10) unsigned DEFAULT '0',
  `modified` int(10) unsigned DEFAULT '0',
  `content` text COMMENT '内容文字',
  `author_id` int(10) unsigned DEFAULT '0',
  `type` varchar(16) DEFAULT 'post',
  `status` varchar(16) DEFAULT 'publish',
  `tags` varchar(200) DEFAULT NULL,
  `categories` varchar(200) DEFAULT NULL,
  `hits` int(10) unsigned DEFAULT '0',
  `comments_num` int(10) unsigned DEFAULT '0',
  `allow_comment` tinyint(1) DEFAULT '1',
  `allow_ping` tinyint(1) DEFAULT '1',
  `allow_feed` tinyint(1) DEFAULT '1',
  PRIMARY KEY (`cid`),
  UNIQUE KEY `slug` (`slug`),
  KEY `created` (`created`)
) ENGINE=InnoDB AUTO_INCREMENT=31 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_contents`
--

LOCK TABLES `t_contents` WRITE;
/*!40000 ALTER TABLE `t_contents` DISABLE KEYS */;
INSERT INTO `t_contents` VALUES (1,'About','about',1514341650,1515141217,'## About Me ##\r\n - 不入流大学CS专业在校生\r\n - Bug驱动的面向Google编程爱好者\r\n - 喜欢听音乐，嵩鼠和姿迷\r\n - 经常看书，手持Kindle\r\n - 沉默寡言，不卑不亢\r\n - +1s  \r\n\r\n\r\n----------\r\n\r\n\r\n## Contact ##\r\n - 常用企鹅：**1002684417**\r\n - 电子邮件：<a href=\"mailto:p9j7stef@gmail.com\">GMail</a>\r\n\r\n\r\n----------\r\n\r\n\r\n## About Blog ##\r\n本博客建立于2017年12月27日。原静态博客为`Hexo`驱动的`gitpage`，现已迁移至`springboot`和`vultr`搭建的动态博客`Myblog`，且更换至新域名。之前写过几篇不多的文章因为博客搬家中自己的不慎而消失了， 重新出发吧！姑且把它当做我的手记本，自省录。\r\n\r\n> 同宇宙的复杂性相比，我们这个世界不过如麻雀的脑髓而已。              --哈特费尔德\r\n                                                                                          ',1,'page','publish',NULL,NULL,702,0,1,1,1),(7,'Twenty','twenty',1513218450,1514363006,'恍惚间，迎来了自己的又一个生日。也是凑巧，石家庄下起了2017年立冬后的第一场雪。这让对大多数节日不怎么上心的我，好歹对20岁的到来有了个不同以往的印象。\r\n\r\n![雪中的牧星湖][1]\r\n\r\n![从教室俯瞰][2]\r\n\r\n说起来还真是惭愧，本来计划着这个学期怎么着也得写上十几篇有质量的干货，但面向Google编程似乎成了我的习惯:p ，别人都总结了的东西再炒冷饭似乎也没什么意思。现在有个想法是写个Lintcode刷题系列，把自己刷过的题相似的类型总结在一起。啥时候开始写？待定吧……期末事情还挺多的:(\r\n\r\n推荐一篇自己读过的散文，勉强拿来当做二十载光阴的一些思索吧，其实我这么多年思维的变化还挺跨越的……\r\n\r\n以下为原文：\r\n\r\n\r\n----------\r\n\r\n\r\n二十岁之前相信的很多东西，后来一件一件变成不相信。\r\n\r\n曾经相信过爱国，后来知道「国」的定义有问题，通常那谆谆善诱要你爱国的人所定义的「国」，不一定可爱，不一定值得爱，而且更可能值得推翻。\r\n\r\n曾经相信过历史，后来知道，原来历史的一半是编造。前朝史永远是后朝人在写，后朝人永远在否定前朝，他的后朝又来否定他，但是负负不一定得正，只是累积渐进的扭曲变形移位，使真相永远掩盖，无法复原。说「不容青史尽成灰」，表达的正是，不错，青史往往是要成灰的。指鹿為马，也往往是可以得逞和胜利的。\r\n\r\n曾经相信过文明的力量，后来知道，原来人的愚昧和野蛮不因文明的进展而消失，只是愚昧野蛮有很多不同的面貌：纯朴的农民工人、深沉的知识份子、自信的政治领袖、替天行道的王师，都可能有不同形式的巨大愚昧和巨大野蛮，而且野蛮和文明之间，竟然只有极其细微、随时可以被抹掉的一线之隔。\r\n\r\n曾经相信过正义，后来知道，原来同时完全可以存在两种正义，而且彼此抵触，冰火不容。选择其中之一，正义同时就意味著不正义。而且，你绝对看不出，某些人在某一个特定的时机热烈主张某一个特定的正义，其中隐藏著深不可测的不正义。\r\n\r\n曾经相信过理想主义者，后来知道，理想主义者往往经不起权力的测试：一掌有权力，他或者变成当初自己誓死反对的「邪恶」，或者，他在现实的场域里不堪一击，一下就被弄权者拉下马来，完全没有机会去实现他的理想。理想主义者要有品格，才能不被权力腐化；理想主义者要有能力，才能将理想转化为实践。可是理想主义者兼具品格及能力者，几希。\r\n\r\n曾经相信过爱情，后来知道，原来爱情必须转化为亲情才可能持久，但是转化为亲情的爱情，犹如化入杯水中的冰块──它还是冰块吗？\r\n\r\n曾经相信过海枯石烂作为永恒不灭的表征，后来知道，原来海其实很容易枯，石，原来很容易烂。雨水，很可能不再来，沧海，不会再成桑田。原来，自己脚下所踩的地球，很容易被毁灭。海枯石烂的永恒，原来不存在。\r\n\r\n二十岁之前相信的很多东西，有些其实到今天也还相信。\r\n\r\n譬如国也许不可爱，但是土地和人可以爱。譬如史也许不能信，但是对于真相的追求可以无止尽。譬如文明也许脆弱不堪，但是除文明外我们其实别无依靠。譬如正义也许极为可疑，但是在乎正义比不在乎要安全。譬如理想主义者也许成就不了大事大业，但是没有他们社会一定不一样。譬如爱情总是幻灭的多，但是萤火虫在夜里发光从来就不是为了保持光。譬如海枯石烂的永恒也许不存在，但是如果一粒沙里有一个无穷的宇宙，一剎那里想必也有一个不变不移的时间。\r\n\r\n那么，有没有什么，是我二十岁前不相信的，现在却信了呢？\r\n\r\n有的，不过都是些最平凡的老生常谈。曾经不相信「性格决定命运」，现在相信了。曾经不相信「色即是空」，现在相信了。曾经不相信「船到桥头自然直」，现在有点信了。曾经不相信无法实证的事情，现在也还没准备相信，但是，有些无关实证的感觉，我明白了，譬如李叔同圆寂前最后的手书：「君子之交，其淡如水，执象而求，咫尺千里。问余何适，廓尔忘言，华枝春满，天心月圆。」\r\n\r\n相信与不相信之间，彷彿还有令人沉吟的深度。\r\n\r\n\r\n  [1]: http://plover.space/upload/2017/12/o78ohfc63ehsoohd4ns46mieeq.jpg\r\n  [2]: http://plover.space/upload/2017/12/uc4rg7uigajasrch1uga1715gu.jpg',1,'post','publish','碎语','生活',563,0,1,1,1),(12,'我的2017','summary',1514634319,1515140951,'## 写在前头 ##\r\n**2017**年在我的指尖悄然流逝，写下这篇文章当做**2017**年我的年终总结。文笔拙劣，引以村上君的一句话来当做提笔的勇气。  \r\n> 不存在十全十美的文章，如同不存在彻头彻尾的绝响。      --《且听风吟》 \r\n\r\n**2017**年对我意义特殊，**20**岁的到来让我感慨良多。村上春树在《舞！舞！舞！》里面这么写到：我一直以为人是慢慢变老的，其实不是，人是一瞬间变老的。我很庆幸，我还年轻，过着相对自由的大学生活，没有那么多的羁绊，因而内心可以有很多情绪而不显沧桑；同时我也明白，这样年轻自由的生活不会太久，就说当下，即将面临的毕业还是考研问题就让我很纠结。很多时候，我就是这样一个矛盾的人。总之岁月漫长，然而值得等待。\r\n\r\n这一年我最大的收获，莫过于学习了**Java**，<del>Java是最好的语言！</del>。以前学校开设的**C**和**C++**，让我对编程有了基础的了解，*《C Primer Plus》* 这本书也看过一些，然而整天对着个命令行注定勾不起我的兴趣。刚想学习一下**QT Creator**，实践一下**C++**，学校的课程计划又开了一门**Java**，在接触了**Java**后，**C**和**C++** 果断就被我抛弃了，<del>网页比命令行有意思多了</del>（naive）……看了很多关于**Java**的书，慕课网上的视频也看了不少，代码也<del>copy</del>写了很多，算是正式入坑了。晒一下我在图书馆的借阅记录，慕课网的学习记录，还有在`Lintcode`上的刷题记录  \r\n\r\n![mooc][5]\r\n\r\n![mooc][6]\r\n\r\n![mooc][1]\r\n\r\n![lintcode][2]\r\n\r\n\r\n\r\n\r\n陈列一下我这一年所接触过的东西吧\r\n\r\n - 编程语言：`Java`，虚拟机，多线程，数据结构，设计模式，`html`，`Java Script`，`Node.js`\r\n - IDE：`IDEA`，`Eclipse`\r\n - 依赖管理：`Maven`，`Gradle`\r\n - 框架和库：`S2SH`（Struts2，Spring，Hibernate），`Logback`，`Mybatis`，`Jackson`，`SpringBoot`，`Bootstrap`，`Bootstrap-table`，`Jquery`，`WebMagic`\r\n - 模板引擎：`Thymeleaf`，`EJS`\r\n - 数据检索：`Lucene`，`ELK`（Elasticsearch，Logstash，Kibana）\r\n - 数据库相关：`MySQL`，`MongoDB`\r\n - 其他：`SSR`翻墙，`Hexo`静态博客，`Git`版本控制和`Github`的使用，`Linux`系统，`Markdown`写作\r\n\r\n上面所提到的，大约占据了我生活的一半时间。**2017**年的其余时间，我在上课，玩手机，打游戏和发呆中度过。\r\n\r\n\r\n----------\r\n下面写点具体的：\r\n## 2017我所关注的 ##\r\n不得不说，知乎成了我获取新闻资讯的唯一来源（一直就很反感百度的广告和今日头条等APP），但我还是为**我的知乎2017**小小的惊讶了下\r\n\r\n![views][3]\r\n\r\n发起了一个热门问题也是挺开心的:-D\r\n\r\n![answer][4]\r\n\r\n#### 2017我在知乎上所关注的热门话题 ####\r\n- 韩国总统朴槿惠下台\r\n- 日本留学生江歌案\r\n- 杭州保姆纵火案\r\n- 邹市明被KO\r\n- 柯杰与`AlphaGo`对弈\r\n- 共享单车的风靡\r\n- 贾跃亭乐视王国的垮塌\r\n- 比特币的疯狂以及前几天钱宝网的崩盘  \r\n\r\n想在浮躁攀比的社会，努力保持一颗安静的心，我觉得**包容**、**相信**、**多加读书**、**努力思考**、**认清自己**、**理解世界**这是我应该恪守的。\r\n\r\n## 2017我的改变 ##\r\n- 意识到埋头写代码不是最重要的，重要的永远是人，交流和沟通很重要 \r\n- 发觉到人生的多种可能性，不要自我设限，而要试着去接触其他领域\r\n- 开始尝试很多很酷的事，依旧在寻找自己的路\r\n## 2018我的期许 ##  \r\n希望自己把所接触过的东西融汇贯通，更加踏实的做事，积极的面对社交  \r\n\r\n嗯……最后，身体健康是最重要的:P\r\n\r\n  [1]: http://plover.space/upload/2017/12/ppak9tnk18gbarvgg4kpl6oa6g.png\r\n  [2]: http://plover.space/upload/2017/12/v3gfpspijuijvospgoisksnd2d.png\r\n  [3]: http://plover.space/upload/2018/01/3ufv0ssvmqh9fo7mq4l70e1ra8.jpg  \r\n  [4]: http://plover.space/upload/2018/01/0k7j9agplagmvoqbqblerod8u8.jpg\r\n  [5]: http://plover.space/upload/2018/01/oc3c6qdupehgsrivl7u3flbr2b.png  \r\n  [6]: http://plover.space/upload/2018/01/v6udi0e0n2j1rrcdeu266tq2kn.png',1,'post','publish','思索','编程,生活',532,0,1,1,1),(14,'Java多线程概述','java-thread',1494579630,1516868338,'## 为什么使用多线程 ##\r\n- 进程之间不能共享内存，但线程之间共享内存很容易\r\n- 系统创建进程需要为该进程重新分配系统资源，但创建线程代价小得多，因此使用多线程来实现多任务并发比多进程的效率高\r\n- JAVA内置了多线程功能支持，而不是单纯的作为底层操作系统的调度方式，从而简化了JAVA的多线程编程\r\n\r\n## 线程的创建 ##\r\n- 继承`Thread`类（可直接使用`this`关键字获得当前对象,多个线程无法共享线程类的实例变量）\r\n- 实现`Runnable`接口（必须使用`Thread.currentThread()`方法，多个线程可以共享线程类的实例变量)\r\n- 使用`Callable`和`Future`创建线程(`call()`方法作为线程执行体，可以有返回值去，可以声明抛出异常）\r\n\r\n## 线程的生命周期 ##\r\n- 新建（New）--使用`new`关键词新建一个线程\r\n- 就绪（Runnable）--调用`start()`方法\r\n- 运行（Running)--处于就绪状态的线程获得CPU，开始执行`run()`方法体\r\n- 阻塞（Blocked）\r\n线程调用`sleep()`方法主动放弃所占用的处理器资源\r\n线程调用了一个阻塞式的IO方法\r\n线程试图获得一个同步监视器，但该监视器被其他线程所持有\r\n线程在等待某个通知\r\n程序调用了线程的`suspend()`方法将该线程挂起（容易导致死锁）\r\n- 死亡（Dead）\r\n`run()`方法或`call()`方法执行完成，线程正常结束\r\n线程抛出一个未捕获的异常\r\n直接调用该线程的`stop()`方法来结束该线程（容易导致死锁）\r\n\r\n## 控制线程 ##\r\n- `join()`方法--当某个程序执行流中调用其他程序的`join()`方法时，调用线程被阻塞，直到`join()`方法加入的join线程执行完为止\r\n- `setDemon()`方法--将指定线程设置为守护线程\r\n- `sleep()`方法--暂停线程的执行，并进入阻塞状态\r\n- `yield()`方法--暂停线程的执行，并进入就绪状态\r\n- `setPriority()`方法--改变线程的优先级，让优先级高的线程获得更多的执行机会\r\n\r\n## 线程同步 ##\r\n- 同步代码块(同步监视器为`obj`)\r\n```\r\nsynchronized(obj){\r\n...\r\n}\r\n```\r\n\r\n- 同步方法(同步监视器为`this`)\r\n```\r\npublic synchronized void draw{\r\n}\r\n```\r\n- 同步锁（Lock）\r\n```\r\n//定义锁对象\r\nprivate final ReentrantLock lock = new ReentrantLock();\r\n//加锁\r\nlock.lock();\r\n//释放锁\r\nlock.unlock();\r\n```\r\n\r\n- 释放同步监视器的锁定\r\n1. 当前线程的同步方法，同步代码块执行结束\r\n2. 当前线程在同步方法，同步代码块遇到`break`,`return`终止了继续执行\r\n3. 当前线程在同步方法，同步代码块出现未处理的异常\r\n4. 当前线程执行同步方法，同步代码块时执行了同步监视器对象的`wait()`方法\r\n- 不释放同步监视器的情况\r\n1. 线程执行同步方法，同步代码块时，程序调用`Thread.sleep()`，`Thread.yield()`方法来暂停当前线程的执行\r\n2. 线程执行同步代码块时，其他线程调用了该线程的`suspend()`方法将该线程挂起\r\n\r\n## 线程通信 ##\r\n- 传统的线程通信\r\n对于使用`synchronized`修饰的同步方法或代码块，借助`Object`类提供的`wait()`,`notify()`,`notifyAll()`方法\r\n- 使用Condition控制线程通信\r\n如果程序显式使用`Lock`对象保证同步，则使用`Condition`对象的`await()`,`signal()`,`signalAll()`来控制程序的协调运行\r\n- 使用阻塞队列（BlockingQueue）控制线程通信\r\n`BlockingQueue`接口：`put()`方法尝试把元素放入队列中，入托队列元素已满，则阻塞该线程，`take()`方法尝试从队列头部去取出元素，如果队列元素已空，则阻塞该线程\r\n\r\n## 线程池 ##\r\n- `Executors`工厂类来产生线程池\r\n```\r\n//返回ExecutorService对象的方法\r\nnewCachedThreadPool()\r\nnewFixedThreadPool(int nThreads)\r\nnewSingleThreadExecutor()\r\n//返回ScheduleExecutorService线程池的方法\r\nnewScheduledThreadPool(int corePoolSize)\r\nnewSingleThreadScheduledExecutor()\r\n//生成work stealing池，相当于后台线程池\r\nExecutorService newWorkStealingPool(int parallelism)\r\nExecutorService newWorkStealingPool()\r\n```\r\n- 创建`Runnable`或者`Callable`实现类的实例\r\n- 调用`ExecutorService`对象的`submit()`方法来提交`Runnable`或者`Callable`实例\r\n- 调用`ExecutorService`对象的`shutdown()`方法关闭线程池\r\n\r\n----------\r\n- `ForkJoinPool`--充分利用多核CPU\r\n1. 创建`ForkJoinPool`实例\r\n2. 创建有继承了返回值的`RecursiveTask`或无返回值的`RecursiveAction`实例\r\n3. 调用`ForkJoinPool`的`submit(ForkJoinTask task)`或`submit(ForkJoinAction action)`方法来执行指定任务\r\n## 线程相关类 ##\r\n- `ThreadLocal`类\r\n隔离多个线程的数据共享，从根本上避免多个线程之间对共享资源的竞争\r\n- 包装线程不安全的集合类\r\n使用`Collections`提供的类方法包装\r\n- 线程安全的集合类\r\n1. 以`Concurrent`开头的集合类\r\n2. 以`CopyOnWrite`开头的集合类\r\n',1,'post','publish','多线程,Java','编程',394,0,1,1,1),(15,'Struts2＋Hibernate框架探险','struts2-hibernate',1497511830,1516868328,'## 写这篇文章的目的 ##\r\n了解 **JavaWeb** 开发的人都知道SSH和SSM框架，前段时间开始接触 **JavaWeb** 开发，看了几个教学视频后就想上手构建一个小型  **Web**项目，可在跟着视频敲代码当中，使用 **Struts2+Hibernate框架** 却不是那么顺利，百度和谷歌都用上，折腾了几天才搞定。究其原因，是因为Struts和Hibernate框架随着版本的升级，部分 **API** 有了很大的变化，然而网上的教程几乎全都是旧版本的，为了让更多的框架使用新手不被新旧版本的更替和网上的过时教程所坑，同时也当作个人的笔记，所以写下了此文。\r\n\r\n## 使用Struts2和Hibernate框架 ##\r\n使用的开发工具为 **Eclipse Java EE IDE for Web Developers Neon.3**，struts2版本为 **struts-2.5.10.1** ，hibernate版本为 **hibernate-release-5.2.9.Final** ，Tomcat和Mysql为工具 **xampp** 最新的整合版本。\r\n### Struts2与Hibernate整合 ###\r\n1. 创建struts2和bibernate用户类库\r\n    不必多说，基本的程序开发操作\r\n2. 导入struts2与hibernate的jar包\r\n    这里需要引起注意，使用Eclipse不仅需要引入用户类库，还需要在项目属性的 **Deployment Assembly** 加入项目所用到的框架以及JDBC驱动\r\n3. 配置web.xml\r\n    加入struts2的过滤器\r\n4. 创建struts.xml\r\n    配置action\r\n5. 创建hibernate.cfg.xml\r\n    配置JDBC驱动和数据库连接信息， **xampp** 整合的为 **MariaDB** ，尽管它是MySQL的一个分支，但它有它专有的驱动，相应的你需要将 `hibernate.connection.driver_class` 配置为 `org.mariadb.jdbc.Driver` ，`hibernate.connection.url` 配置为 `jdbc:mariadb` ，而 `hibernate.dialect` 仍使用**MySQL** 的配置就好了。在这个文件里你同时也需要配置 `mapping resource` 的值为 **hbm.xml** 即对象关系映射文件的位置\r\n#### 取巧而不是蛮干 ####\r\n- 使用 **Maven** 管理项目的依赖问题\r\n- 复制修改使用下载的 **struts2** 解压包内示例的 **struts.xml** 文件\r\n- Eclipse可以使用 **hibernate tools for eclipse** 插件来生成 **hbm.xml** 文件，它决定了实体类在数据库中生成的表结构\r\n- Eclipse可以使用 **StrutsClipse** 插件来获得 **struts.xml** 的错误提醒\r\n- 使用 **JUnit** 测试框架来及时调试代码\r\n## 编程中遇到的问题以及解决办法 ##\r\n- 在使用 **JUnit** 和 **Hibernate** 框架自带的 **SchemaExport** 测试创建表结构时，无法在数据库中生成表结构，利用百度和谷歌，自己多次排查，找出原因为 **Hibernate** 新版本创建数据库连接 **Session** 的 **API** 和 **SchemaExport** **API** 均有所改变。\r\n>旧版本代码\r\n\r\n```\r\n//创建配置对象\r\nConfiguration config = new Configuration().configure();\r\n//创建服务注册对象\r\nServiceRegistry serviceRegistry = new ServiceRegistryBuilder().applySettings(config.getProperties()).buildServiceRegistry();\r\n//创建sessionFactory\r\nSessionFactory sessionFactory = config.buildSessionFactory(serviceRegistry);\r\n//创建session对象\r\nSession session = sessionFactory.getCurrentSession();\r\n//创建SchemaExport对象来生成表结构\r\nSchemaExport export = new SchemaExport(config);\r\nexport.create(true,true);\r\n```\r\n\r\n> 新版本代码\r\n\r\n```\r\nConfiguration config = new Configuration().configure();\r\nServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().configure().build();\r\nSessionFactory sessionFactory = config.buildSessionFactory(serviceRegistry);\r\nSession session = sessionFactory.getCurrentSession();\r\nMetadata metadata = new MetadataSources(serviceRegistry).buildMetadata();\r\nSchemaExport export = new SchemaExport();\r\nexport.create(EnumSet.of(TargetType.DATABASE), metadata);\r\n```\r\n- 在使用 **Struts.xml** 文件进行页面调用时，**Tomcat** 报错\r\n![](http://i.imgur.com/s4bTbPN.png)  ![](http://i.imgur.com/ndzIVwp.png)\r\n\r\n    又是一番排查，原因依旧是新旧版本的更替问题，因为我在 **struts.xml** `action` 中采用了`*_*`通配符调用动态方法，所以需要加入`<constant name=\"struts.enable.DynamicMethodInvocation\" value=\"false\" />` 以及 `<allowed-methods>允许调用的方法名,多个方法用逗号隔开</allowed-methods>` 才能允许动态方法的调用，其实返回的错误信息已经说明了这个问题。\r\n## 思索和建议 ##\r\n初次动手使用框架来进行 **JavaWeb** 开发，尽管是一个小型的工程，却也花费了我很多时间，中间还有很多没有言说的磕磕绊绊。造成这种情况的原因大概有两点\r\n- 初次使用框架，相对来说各个组件的配置和功能并不是那么了解的透彻\r\n- 网上的相关教程大多数是 **Copy** 一份的，这点使用 **百度** 搜索体现的尤为明显，**谷歌** 相对来说较好，但也存在教程过时，不适配更新后的框架，极易误导新手，学习环境并没有像大多数人说的那么友好。真正的大神都在闷声发大财，不会在意这些鸡毛蒜皮的事(逃\r\n\r\n\r\n\r\n\r\n',1,'post','publish','Java,框架','编程',573,0,1,1,1),(16,'ELK的搭建和配置','elasticsearch',1515397618,1517222643,'## 什么是ELK ##\r\n**ELK**即*Elasticsearch*、*Logstash*、*Kibana*，它在最近两年迅速崛起，成为数据分析的第一选择。和传统的技术相比，**ELK**具有如下几个优点：\r\n\r\n- 配置简易上手。Elasticsearch 全部采用 JSON 接口，Logstash 是 Ruby DSL 设计，都是目前业界最通用的配置语法设计；\r\n- 检索性能高效。虽然每次查询都是实时计算，但是优秀的设计和实现基本可以达到全天数据查询的秒级响应；\r\n- 集群线性扩展。不管是 Elasticsearch 集群还是 Logstash 集群都是可以线性扩展的；\r\n- 前端操作炫丽。Kibana 界面上，只需要点击鼠标，就可以完成搜索、聚合功能，生成炫丽的仪表板。\r\n\r\n总结一下，Logstash 收集数据，Elasticsearch 索引数据，Kibana 展示数据，ELK 套餐，就是这么简单。\r\n## ELK的安装配置 ##\r\n### 安装 ###\r\n默认需要先安装**JDK1.8**，自行安装即可。  \r\n\r\n1. [Elasticsearch](https://www.elastic.co/downloads)官网下载*Elasticsearch*（https://www.elastic.co/downloads）\r\n![Elasticsearch官网](http://plover.space/upload/2018/01/p92m1qiufegc6o895jp9imr9t7.png)\r\n2. *Linux*平台建议选择**TAR**包(当前最新版本为**6.1.2**）\r\n![ElasticsearchDownload](http://plover.space/upload/2018/01/3k8lm06kuego1phcrgbl2psaf8.png)\r\n3. 同样的，分别下载*Logstash*和*Kibana*，需要注意的是，必须确保三者版本一致。\r\n\r\n### 配置 ###\r\n解压下载的3个**TAR**包，本文以路径为*/usr/share*为例进行简单的配置\r\n\r\n1. 配置*Elasticsearch*，修改以下2项：`vim /usr/share/elasticseach/config/elasticsearch.yml`\r\n\r\n```bash\r\n#配置网络访问，修改成本机ip以支持远程访问\r\nnetwork.host: 192.168.10.95\r\n#允许JS跨域调用\r\nhttp.cors.enabled: true\r\n#允许的规则\r\nhttp.cors.allow-origin: \"*\"\r\n```\r\n\r\n2. 配置*Kibana*，修改以下2项：`vim /usr/share/kibana/config/kibana.yml`\r\n\r\n```bash\r\n#配置网络访问，修改成本机ip以支持远程访问\r\nserver.host: \"192.168.10.95\"\r\n#需要访问的 elasticsearch 的 url\r\nelasticsearch.url: \"http://192.168.10.95:9200\"\r\n```\r\n\r\n3.*Logstash*配置无需更改\r\n\r\n## ELK的使用 ##\r\n以某一部分数据集为例，进行基本的索引创建，可视化分析操作\r\n数据以**csv**格式存储于*/usr/share/test/countries.csv*，以下为部分数据\r\n\r\n>id;continent;name;capital;iso-2;iso-3;ioc;tld;currency;phone;utc;wiki;name_de;capital_de;wiki_de\r\n>1;Asia;Afghanistan;Kabul;AF;AFG;AFG;.af;AFN;+93;270;;Afghanistan;Kabul;\r\n>2;Africa;Egypt;Kairo;EG;EGY;EGY;.eg;EGP;+20;120;;Ägypten;Kairo;http://de.wikipedia.org/wiki/Ägypten\r\n>3;Europe;Åland Islands;Mariehamn;AX;ALA;;.ax;EUR;+35818;120;;Aland;Mariehamn;\r\n>4;Europe;Albania;Tirana;AL;ALB;ALB;.al;ALL;+355;60;;Albanien;Tirana;\r\n>5;Africa;Algeria;Algier;DZ;DZA;ALG;.dz;DZD;+213;60;;Algerien;Algier;\r\n>6;Australia;American Samoa;Pago-Pago;AS;ASM;;.as;USD;+1684;-660;;Amerikanisch-Samoa;Pago-Pago;\r\n>7;South America;Virgin Islands, U.s.;Charlotte Amalie;VI;VIR;;.vi;USD;+1340;-240;;Amerikanische Jungferninseln;Charlotte Amalie;\r\n>8;Europe;Andorra;Andorra la Vella;AD;AND;AND;.ad;EUR;+376;60;;Andorra;Andorra la Vella;\r\n>\r\n### Logstash创建索引 ###\r\n 启动`Elasticsearch`和`Kibana`服务，运行bin目录的同名脚本命令，加-d参数后台运行。\r\n- 由已知的数据格式编写**Logstash**的流处理配置文件：`vim /usr/share/logstash/test.conf`\r\n```bash\r\n# input ，filter，output里配置插件\r\ninput {\r\n#使用 file 插件导入数据\r\n  file {\r\n   #需要导入的数据路径\r\n    path => \"/usr/share/test/countries.csv\"\r\n   #从文件头导入\r\n    start_position => \"beginning\"\r\n   #记录文件导入到了哪行，若不配置则默认记录，导致数据只能导入一次\r\n    sincedb_path => \"/dev/null\"\r\n  }\r\n}\r\nfilter {\r\n#使用 csv 插件格式化数据\r\n  csv {\r\n  #指定分隔符\r\n    separator => \";\"\r\n    #由数据格式配置字段索引名称\r\n    columns => [\"id\",\"continent\",\"name\",\"capital\",\"iso-2\",\"iso-3\",\"ioc\",\"tld\",\"currency\",\"phone\",\"utc\",\"wiki\",\"name_de\",\"capital_de\",\"wiki_de\"]\r\n  }\r\n}\r\noutput {\r\n     #使用 elasticsearch 插件导出\r\n     elasticsearch {\r\n     #elasticsearch ip地址\r\n     hosts => \"http://192.168.10.95:9200\"\r\n     #建立索引的名称\r\n     index => \"countries\"\r\n    }\r\n    #同时使用 stdout 插件打印至终端\r\n    stdout {\r\n    }\r\n}\r\n```\r\n\r\n- 使用*Logstash*导入数据至*Elasticsearch*：`/usr/share/logstash/bin/logstash -f /usr/share/logstash/test.conf`\r\n![LogstashImport](http://plover.space/upload/2018/01/t9sh0ip0nkj1cp1l83mg67nes2.png)\r\n\r\n### Kibana可视化分析 ###\r\n*Kibana*默认运行于5601端口，依照之前的配置，我们访问<u>192.168.10.95:5601</u>即可。\r\n\r\n![KibanaUI](http://plover.space/upload/2018/01/1pfcck64kahhcrbo9v7j741a2s.png)\r\n\r\n- 选择**TimeLion**查看*Elasticsearch*的运行状况，下图可以看到我们刚才导入了数据\r\n![KibanaTimeLion](http://plover.space/upload/2018/01/o0cnk6de76hdmqj4pk03gjlj5d.png)  \r\n- 选择**Management**的**Index Patterns**在*Kibana*使用索引数据\r\n![KManage](http://plover.space/upload/2018/01/774vkg2u3qjjdou52m5o025fju.png)\r\n![KCountries](http://plover.space/upload/2018/01/53hsef72iqg4rrvuluvfole81r.png)  \r\n- 选择**Discover**查看名为**countries**的索引\r\n![KDiscover](http://plover.space/upload/2018/01/rbqa2f42e2gklq0lhb4d0739h1.png)\r\n查看具体的一条索引数据字段\r\n![oneData](http://plover.space/upload/2018/01/7dp8i40s5qjfgof5ia8qqki440.png)  \r\n- 选择**Visualize**创建图表\r\n![KVis](http://plover.space/upload/2018/01/0n4odd8dvkhl7pc4ckt98crfvd.png)\r\n以七大洲的国家数目生成饼状图\r\n![bing](http://plover.space/upload/2018/01/34avark8tsif5r1l3mp087tfts.png)\r\n按索引数量生成词云\r\n![ciyun](http://plover.space/upload/2018/01/68thdlg93sjj9rpdmv86a7vm5l.png)\r\n\r\n**Kibana**的强大随着你数据的复杂更加体现出来，这里仅仅作为实例。\r\n\r\n### Elasticseach查询 ###\r\n数据索引的目的就是为了查询，**Elasticsearch**将其用**Restful**以及**Json**做的非常优雅\r\n\r\n- 查看*counties*索引\r\n```bash\r\n$ curl \'192.168.10.95:9200/countries\'\r\n```\r\n- 搜索具体的某一条记录：continent字段为Asia，从0开始返回10条记录\r\n```bash\r\n$ curl ‘192.168.10.95:9200/countries/_search?q=+continent:Asia&size=10&from=0’\r\n```\r\n- 删除和更新某条记录在大数据分析中不常用，在此不赘述\r\n\r\n## 参考文档 ##\r\n\r\n- [Elasticsearch权威指南](https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html)\r\n- [Logstash Reference](https://www.elastic.co/guide/en/logstash/current/index.html)\r\n- [Kibana简易教程](http://www.cnblogs.com/yiwangzhibujian/p/7137546.html)',1,'post','publish','大数据,Java,Elasticsearch','编程',805,0,1,1,1),(17,'Java程序员的自我修养','java-coder',1515833215,1515833725,'写下我作为一个**Java**开发者，编程路上积累的一些东西。  \r\n## Linux篇 ##\r\n- `cd ~`命令快速回到用户主目录\r\n- `rm -rf`命令强制删除目录及文件\r\n- `tar -zxvf`解压*tar.gz*包\r\n- `tar -xvf`解压*tar*包\r\n- `unzip`解压*zip*包\r\n- `unrar e`解压*rar*包\r\n- `file *`命令查看目录下文件编码\r\n- `cat * -n 1`命令查看目录下文件第1行\r\n- `tail * -n 1`命令查看目录下文件倒数第1行\r\n- `du -h`命令查看目录下文件大小\r\n- `df -h`命令查看磁盘挂载情况\r\n- `lscpu`查看cpu型号\r\n- `free -m`查看内存使用情况\r\n- `uname -a`查看内核信息\r\n- `netstat -lntp`列出所有监听端口\r\n- `ps -ef | grep logstash`列出系统运行的进程并查找logstash关键字\r\n- `nohup java -jar demo.jar&`使程序在后台运行\r\n- `kill -9 3601`强制停止id为3601的进程\r\n- `iconv -f gb18030 -t utf-8 input.txt>output.txt`将*GB18030*编码转为*UTF-8*（iso可以转utf8\r\nutf8不可以回转iso\r\nutf8包括ascii，所以ascii不需要转utf8）\r\n- `rename \"s/.csv//\" *.*.csv`将文件名称中多余的.csv字符串去除且不删除文件的后缀\r\n- `iptables -L -n`列出防火墙规则\r\n- `iptables -A INPUT -p tcp --dport 5601 -j ACCEPT`防火墙暂时添加规则，允许5601端口的tcp协议访问\r\n- `iptables -A OUTPUT -p tcp --sport 5601 -j ACCEPT`防火墙暂时添加规则，允许5601端口的tcp协议发送\r\n- `iptables -D INPUT 1`删除防火墙*Chain INPUT*规则的第1条\r\n- `Ctrl`+`A`光标快速跳到命令行行头\r\n- `Ctrl`+`A`光标快速跳到命令行行尾\r\n- `Ctrl`+`U`删除光标前的字符\r\n- `Ctrl`+`K`删除光标后的字符\r\n- `Ctrl`+`L`清空终端\r\n- `ssh root@192.168.10.95`ssh连接到远程主机\r\n- `scp ~/test.txt root@192.168.10.95:/root`scp传输文件到远程主机\r\n- `scp -r ~/test root@192.168.10.95:/root`scp传输目录到远程主机\r\n\r\n## Java篇 ##\r\n### 配置环境变量 ###\r\n- `sudo vim /etc/profile`\r\n```bash\r\n#配置Java目录\r\nJAVA_HOME=/usr/java/jdk1.8.0_144/\r\n#配置Lucene目录\r\nLUCENE_HOME=/home/vae/lucene-7.1.0\r\nPATH=$JAVA_HOME/bin:$PATH\r\nCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$LUCENE_HOME/lucene-core-7.1.0.jar:$LUCENE_HOME/lucene-demo-7.1.0.jar:$LUCENE_HOME/lucene-queryparser-7.1.0.jar:$LUCENE_HOME/lucene-analyzers-common-7.1.0.jar:\r\nexport JAVA_HOME\r\nexport PATH\r\nexport CLASSPATH\r\n#配置Maven目录\r\nMAVEN_HOME=/usr/local/apache-maven-3.5.0\r\nexport MAVEN_HOME\r\nexport PATH=${MAVEN_HOME}/bin:${PATH}\r\n#配置Gradle目录\r\nexport GRADLE_HOME=/usr/local/gradle-4.2.1\r\nexport PATH=$GRADLE_HOME/bin:${PATH}\r\n                                         \r\n```\r\n### 安装配置MySQL ###\r\n1. `sudo apt-get install mysql-server mysql-client `\r\n2. 修改编码为**utf-8**，`sudo vim /etc/mysql/my.cnf`\r\n```bash\r\n[client]\r\nport            = 3306\r\nsocket          = /var/run/mysqld/mysqld.sock\r\n#添加这行\r\ndefault-character-set=utf8\r\n[mysqld]\r\nuser            = mysql\r\npid-file        = /var/run/mysqld/mysqld.pid\r\nsocket          = /var/run/mysqld/mysqld.sock\r\nport            = 3306\r\n#添加这行\r\ncharacter-set-server=utf8\r\nbasedir         = /usr\r\ndatadir         = /var/lib/mysql\r\ntmpdir          = /tmp\r\nlc-messages-dir = /usr/share/mysql\r\nskip-external-locking\r\n```\r\n3. *MySQL*出现问题后的彻底卸载\r\n```bash\r\nsudo service mysql stop  #or mysqld\r\nsudo killall -9 mysql\r\nsudo killall -9 mysqld\r\nsudo apt-get remove --purge mysql-server mysql-client mysql-common\r\nsudo apt-get autoremove\r\nsudo apt-get autoclean\r\nsudo deluser mysql\r\nsudo rm -rf /var/lib/mysql\r\nsudo rm -rf /etc/mysql\r\nsudo apt-get purge mysql-server-core-5.5\r\nsudo apt-get purge mysql-client-core-5.5\r\n```\r\n',1,'post','publish','Java,实用指南','编程',565,0,1,1,1),(18,'SSM框架整合实践','spring-springmvc-mybatis',1517646111,1517655649,'**SSM**即当下在**Java**技术栈流行的**Spring**，**SpringMVC**，**Mybatis**三大框架，运用这3个框架，可以构建出一个架构优雅的`Web`应用。\r\n## 分析需求 ##\r\n假定我们需要实现一个商品管理系统，它的需求如下：\r\n\r\n 1. 用户注册\r\n 2. 用户登录及注销\r\n 3. 商品录入\r\n 4. 商品展示及编辑\r\n\r\n## 技术实现 ##\r\n### 环境搭建 ###\r\n使用**Maven**构建项目，**pom.xml**如下：\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\r\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    <modelVersion>4.0.0</modelVersion>\r\n\r\n    <groupId>space.plover</groupId>\r\n    <artifactId>permiss</artifactId>\r\n    <version>1.0-SNAPSHOT</version>\r\n    <dependencies>\r\n        <!--servlet jar包-->\r\n        <dependency>\r\n            <groupId>javax.servlet</groupId>\r\n            <artifactId>javax.servlet-api</artifactId>\r\n            <version>3.1.0</version>\r\n            <scope>provided</scope>\r\n        </dependency>\r\n        <!--springmvc jar包-->\r\n        <dependency>\r\n            <groupId>org.springframework</groupId>\r\n            <artifactId>spring-webmvc</artifactId>\r\n            <version>5.0.0.RELEASE</version>\r\n        </dependency>\r\n        <!--mysql数据库驱动-->\r\n        <dependency>\r\n            <groupId>mysql</groupId>\r\n            <artifactId>mysql-connector-java</artifactId>\r\n            <version>5.1.6</version>\r\n            <scope>runtime</scope>\r\n        </dependency>\r\n        <!--c3p0连接池-->\r\n        <dependency>\r\n            <groupId>com.mchange.c3p0</groupId>\r\n            <artifactId>com.springsource.com.mchange.v2.c3p0</artifactId>\r\n            <version>0.9.1.2</version>\r\n        </dependency>\r\n        <!--mybatis与spring整合的jar包-->\r\n        <dependency>\r\n            <groupId>org.mybatis</groupId>\r\n            <artifactId>mybatis-spring</artifactId>\r\n            <version>1.3.1</version>\r\n        </dependency>\r\n        <!--mybatis jar包-->\r\n        <dependency>\r\n            <groupId>org.mybatis</groupId>\r\n            <artifactId>mybatis</artifactId>\r\n            <version>3.4.5</version>\r\n        </dependency>\r\n        <!--springjdbc jar包-->\r\n        <dependency>\r\n            <groupId>org.springframework</groupId>\r\n            <artifactId>spring-jdbc</artifactId>\r\n            <version>5.0.0.RELEASE</version>\r\n        </dependency>\r\n        <!--springtest 依赖 junit jar包-->\r\n        <dependency>\r\n            <groupId>junit</groupId>\r\n            <artifactId>junit</artifactId>\r\n            <version>4.12</version>\r\n            <scope>test</scope>\r\n        </dependency>\r\n        <!--springtest jar包-->\r\n        <dependency>\r\n            <groupId>org.springframework</groupId>\r\n            <artifactId>spring-test</artifactId>\r\n            <version>5.0.0.RELEASE</version>\r\n            <scope>test</scope>\r\n        </dependency>\r\n        <!--数据校验的jar包-->\r\n        <dependency>\r\n            <groupId>org.hibernate.validator</groupId>\r\n            <artifactId>hibernate-validator</artifactId>\r\n            <version>6.0.7.Final</version>\r\n        </dependency>\r\n        <!--jsp 使用 jstl标签-->\r\n        <dependency>\r\n            <groupId>jstl</groupId>\r\n            <artifactId>jstl</artifactId>\r\n            <version>1.2</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>taglibs</groupId>\r\n            <artifactId>standard</artifactId>\r\n            <version>1.1.2</version>\r\n        </dependency>\r\n        <!--文件上传相关 jar包-->\r\n        <dependency>\r\n            <groupId>commons-fileupload</groupId>\r\n            <artifactId>commons-fileupload</artifactId>\r\n            <version>1.3.3</version>\r\n        </dependency>\r\n    </dependencies>\r\n</project>\r\n```  \r\n\r\n数据库创建**User**用户表和**Product**产品表\r\n```sql\r\nCREATE TABLE `pl_user` (\r\n  `ID` int(11) NOT NULL AUTO_INCREMENT,\r\n  `username` varchar(50) NOT NULL DEFAULT \'\',\r\n  `password` varchar(50) NOT NULL DEFAULT \'\',\r\n  PRIMARY KEY (`ID`)\r\n) ENGINE=InnoDB AUTO_INCREMENT=35 DEFAULT CHARSET=utf8\r\n```   \r\n\r\n```sql\r\nCREATE TABLE `pl_product` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'商品id\',\r\n  `name` varchar(255) NOT NULL COMMENT \'商品名\',\r\n  `price` double NOT NULL DEFAULT \'0\' COMMENT \'商品单价\',\r\n  `date` date NOT NULL COMMENT \'出厂日期\',\r\n  `pic` varchar(255) DEFAULT NULL COMMENT \'商品图片\',\r\n  PRIMARY KEY (`id`)\r\n) ENGINE=InnoDB AUTO_INCREMENT=24 DEFAULT CHARSET=utf8 COMMENT=\'商品录入表\'\r\n```  \r\n\r\n### 框架整合 ###\r\n**SSM**框架整合最终目的是利用**Spring**框架完成依赖注入（控制反转），即将**Springmvc**、**Mybatis**以及相关的`Bean`由**Spring**来管理。\r\n创建好项目目录、相应的类和配置文件：\r\n![包结构][1]\r\n`springmvc.xml`即**Spring**框架的配置文件，内容如下：\r\n```xml\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\r\n       xmlns:context=\"http://www.springframework.org/schema/context\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\r\n		http://www.springframework.org/schema/beans/spring-beans.xsd\r\n		http://www.springframework.org/schema/mvc\r\n		http://www.springframework.org/schema/mvc/spring-mvc.xsd\r\n		http://www.springframework.org/schema/context\r\n		http://www.springframework.org/schema/context/spring-context.xsd\">\r\n\r\n    <!-- 组件扫描，由于使用自动扫描所以action类不用在spring配置文件中配置 -->\r\n    <context:component-scan base-package=\"controller\"/>\r\n    <context:component-scan base-package=\"mapper\"/>\r\n    <context:component-scan base-package=\"service\"/>\r\n    <!--jdbc.properties文件包含-->\r\n    <context:property-placeholder location=\"classpath:jdbc.properties\"/>\r\n    <!--开启springmvc默认的servlet,针对静态资源处理-->\r\n    <mvc:default-servlet-handler/>\r\n    <!--针对数据校验和日期转换-->\r\n    <mvc:annotation-driven validator=\"validator\" conversion-service=\"conversionService\"/>\r\n    <!--配置自定义的日期转换Bean-->\r\n    <bean id=\"conversionService\" class=\"org.springframework.format.support.FormattingConversionServiceFactoryBean\">\r\n        <property name=\"converters\">\r\n            <list>\r\n                <bean class=\"controller.converter.CustomDateConverter\"/>\r\n            </list>\r\n        </property>\r\n    </bean>\r\n    <!--配置文件上传Bean-->\r\n    <bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\">\r\n        <property name=\"maxUploadSize\" value=\"5242880\"/>\r\n    </bean>\r\n    <!--配置拦截器，实现url拦截登录-->\r\n    <mvc:interceptors>\r\n        <mvc:interceptor>\r\n            <mvc:mapping path=\"/**\"/>\r\n            <bean class=\"interceptor.LoginInterceptor\"/>\r\n        </mvc:interceptor>\r\n    </mvc:interceptors>\r\n    <!--此处为坑，多次配置会使上面的同样配置无效-->\r\n    <!--<mvc:annotation-driven/>-->\r\n    <!-- 视图解析器 -->\r\n    <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\r\n        <!-- 前缀和后缀可以去掉的，为了方便开发才加的 -->\r\n        <property name=\"prefix\" value=\"/WEB-INF/jsp/\"/>\r\n        <property name=\"suffix\" value=\".jsp\"/>\r\n    </bean>\r\n    <!--配置c3p0连接池-->\r\n    <bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\">\r\n        <property name=\"jdbcUrl\" value=\"${jdbc.url}\"/>\r\n        <property name=\"driverClass\" value=\"${jdbc.driver}\"/>\r\n        <property name=\"user\" value=\"${jdbc.username}\"/>\r\n        <property name=\"password\" value=\"${jdbc.password}\"/>\r\n    </bean>\r\n    <!--配置sqlSessionFactory Bean-->\r\n    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\r\n        <property name=\"dataSource\" ref=\"dataSource\"/>\r\n        <property name=\"configLocation\" value=\"classpath:mybatis.xml\"/>\r\n        <property name=\"mapperLocations\" value=\"classpath:mapper/*.xml\"/>\r\n    </bean>\r\n    <!--配置mybatis-->\r\n    <bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\r\n        <property name=\"basePackage\" value=\"mapper\"/>\r\n    </bean>\r\n    <!-- 校验器，LocalValidatorFactoryBean是spring提供的一个校验接口-->\r\n    <bean id=\"validator\" class=\"org.springframework.validation.beanvalidation.LocalValidatorFactoryBean\">\r\n        <!-- hibernate校验器 -->\r\n        <property name=\"providerClass\" value=\"org.hibernate.validator.HibernateValidator\"/>\r\n        <!--指定校验使用的资源文件，在文件中配置校验错误信息，如果不指定则默认使用classpath下的ValidationMessages.properties-->\r\n        <property name=\"validationMessageSource\" ref=\"messageSource\"/>\r\n    </bean>\r\n    <!-- 校验错误信息配置文件 -->\r\n    <bean id=\"messageSource\" class=\"org.springframework.context.support.ReloadableResourceBundleMessageSource\">\r\n        <!-- 资源文件名 -->\r\n        <property name=\"basenames\">\r\n            <list>\r\n                <value>classpath:CustomValidationMessages</value>\r\n            </list>\r\n        </property>\r\n        <property name=\"defaultEncoding\" value=\"utf-8\"/>\r\n        <!-- 资源文件编码格式 -->\r\n        <!--<property name=\"fileEncodings\" value=\"utf-8\" />-->\r\n        <!-- 对资源文件内容缓存时间，单位秒 -->\r\n        <property name=\"cacheSeconds\" value=\"120\"/>\r\n    </bean>\r\n</beans>\r\n```\r\n由此配置文件，基本完成了**SSM**三大框架的整合。\r\n\r\n## 关键细节 ##\r\n\r\n - 用户注册合法校验\r\n - 部分`url`必须用户登录才可访问\r\n - 商品图片的上传和访问\r\n - 涉及日期字段的处理和商品修改细节\r\n\r\n## 问题解决 ##\r\n\r\n 1. **Spring**提供了内置的校验接口，可以引入及配置**HibernateValidator**，结合**Spring**内置的`@Validated`注解，完成对用户注册规则的校验。相关文件如下：\r\n![UserEntity][2]![UserController][3]![ValidateMessage][4]\r\n 2. 使用**Spring**框架支持的拦截器，配置成除公开url、用户登录和注册url的访问外都重定向到登录的url。相关文件如下：\r\n![Interceptor][5]\r\n造成的问题是，静态资源也被拦截，注意到**springmvc.xml**文件中我启用了**Spring**默认的*Servlet*，它将与**web.xml**的相关配置解决这个问题，**web.xml**文件如下：\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<web-app id=\"WebApp_9\" version=\"3.0\" xmlns=\"http://java.sun.com/xml/ns/javaee\"\r\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee\r\n  http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\">\r\n    <display-name>ssmdemo</display-name>\r\n    <servlet>\r\n        <servlet-name>springmvc</servlet-name>\r\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\r\n        <init-param>\r\n            <param-name>contextConfigLocation</param-name>\r\n            <param-value>classpath:springmvc.xml</param-value>\r\n        </init-param>\r\n    </servlet>\r\n    <servlet-mapping>\r\n        <servlet-name>springmvc</servlet-name>\r\n        <url-pattern>/</url-pattern>\r\n    </servlet-mapping>\r\n    <!--与springmvc开启默认servlet配合使用-->\r\n    <!--！！！且必须在自定义的Servlet后配置-->\r\n    <servlet-mapping>\r\n        <servlet-name>default</servlet-name>\r\n        <url-pattern>/js/*</url-pattern>\r\n        <url-pattern>/css/*</url-pattern>\r\n        <url-pattern>/pic/*</url-pattern>\r\n        <url-pattern>/fonts/*</url-pattern>\r\n    </servlet-mapping>\r\n    <!--spring的编码过滤器解决乱码问题 -->\r\n    <filter>\r\n        <filter-name>characterencoding</filter-name>\r\n        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\r\n        <init-param>\r\n            <param-name>encoding</param-name>\r\n            <param-value>utf-8</param-value>\r\n        </init-param>\r\n        <init-param>\r\n            <param-name>forceRequestEncoding</param-name>\r\n            <param-value>true</param-value>\r\n        </init-param>\r\n    </filter>\r\n    <filter-mapping>\r\n        <filter-name>characterencoding</filter-name>\r\n        <url-pattern>/*</url-pattern>\r\n    </filter-mapping>\r\n    <welcome-file-list>\r\n        <welcome-file>index.jsp</welcome-file>\r\n    </welcome-file-list>\r\n</web-app>\r\n```\r\n 3. 商品图片上传后，保存在磁盘上而不是数据库中，数据库中存储图片的名称，需要访问图片时，读取`product.pic`字段即可。相关文件如下：\r\n![图片存储][6]![图片访问][7]\r\n 4. 针对商品的`date`字段，配置**Spring**的转换器，由`Request`传过来的`String`类型转为`Date`类型。相关文件如下：\r\n![转换器][8]\r\n\r\n而在商品修改操作中，思路是先由`id`字段查出商品的数据，然后再进行更新操作，且包含文件提交的表单，必须如下定义（`method`为**post**、`enctype`为**multipart/form-date**，否则出错：\r\n```html\r\n    <form action=\"/product/create\" method=\"post\" enctype=\"multipart/form-data\">\r\n        <div class=\"form-group\">\r\n            <label for=\"exampleInputEmail1\">商品名称</label>\r\n            <input name=\"name\" type=\"text\" class=\"form-control\" id=\"exampleInputEmail1\" placeholder=\"ProductName\"/>\r\n        </div>\r\n        <div class=\"form-group\">\r\n            <label for=\"exampleInputPassword1\">商品价格</label>\r\n            <input name=\"price\" type=\"text\" class=\"form-control\" id=\"exampleInputPassword1\" placeholder=\"ProductPrice\"/>\r\n        </div>\r\n        <div class=\"form-group\">\r\n            <label for=\"exampleInput\">出厂日期</label>\r\n            <input name=\"date\" type=\"date\" class=\"form-control\" id=\"exampleInput\" placeholder=\"ProductDate\"/>\r\n        </div>\r\n        <div class=\"form-group\">\r\n            <label for=\"example\">商品图片</label>\r\n            <input type=\"file\" id=\"example\" name=\"picFile\"/>\r\n        </div>\r\n        <button type=\"submit\" class=\"btn btn-default\">Submit</button>\r\n    </form>\r\n```\r\n## 相关工具 ## \r\n\r\n - [mybatis-generator-gui][9]：**Mybatis**映射文件生成的图形工具，相当实用。\r\n - [thymeleaf][10]：**Spring**推荐的模板引擎，特有标签库结合**Spring**。\r\n - [手把手教你整合最优雅的SSM框架][11]：**SSM**整合入门级教程。\r\n\r\n  \r\n\r\n\r\n  [1]: http://plover.space/upload/2018/02/ppua1psoomjh8qbut2avp1r5ia.png\r\n  [2]: http://plover.space/upload/2018/02/oe4g9i8lsgh2irj879njarivq6.png\r\n  [3]: http://plover.space/upload/2018/02/5qk57255ughv8pf6jfspejh4rv.png\r\n  [4]: http://plover.space/upload/2018/02/46kc5fo2d0jslo49p16774buj5.png\r\n  [5]: http://plover.space/upload/2018/02/rrs4jue9r8janpec3o8hnsspd0.png\r\n  [6]: http://plover.space/upload/2018/02/4qhkoj5rhmjtko7u7i7tflclij.png\r\n  [7]: http://plover.space/upload/2018/02/3r4c96oqdeg4fp8mg92ikcra64.png\r\n  [8]: http://plover.space/upload/2018/02/6fofg2a9q4ivpqt8v8ld526cgl.png\r\n  [9]: https://github.com/zouzg/mybatis-generator-gui\r\n  [10]: http://www.thymeleaf.org/\r\n  [11]: https://github.com/liyifeng1994/ssm',1,'post','publish','Spring,SpringMVC,Mybatis,实用指南,Java,框架','编程',592,0,1,1,1),(19,'2月的尾巴','end-of-february',1519637688,1530271527,'二月就要过去了，开学在即啊:grinning:\r\n\r\n嗯，一个寒假没怎么更新博客，实际上还是做了一些微小的工作的。\r\n\r\n - 学习了一下**shiro**、**spring security**\r\n - 尝试写一个**blog**，写了一点放弃了\r\n - 看了一下**微服务**相关的东西，不过也是浅谈辙止了\r\n\r\n仔细的想了一下，还是决定考研（尽管知乎上我关注的几个大V都说不考研比较好？），原因如下：\r\n\r\n 1. 以前觉得写代码是创造，现在发现原来大部分时间是模仿，感觉没啥意思（事实是没天赋？）\r\n 2. 赶快去工作是很好啊，能**make money**了，但是挣钱花在哪里呢？（个人真的物质需求不高）\r\n 3. 人生还很长，考个研提升一下平台，以后好拿来吹水？（自我救赎一下，高中挖的坑啊)\r\n 4. 一想到考研成功后，能和从小到大的小伙伴在一个城市玩耍，心里还有点小激动2333（还是比较爱玩）\r\n\r\n正经点的说，目标湖南大学。浏览了一下计算机系历年来的招生计划，感觉学硕不太好考啊（保送名额占了总名额的**3/4**，还有夏令营计划优先**985、211**）。所以决定考专硕了，初试科目也相对容易点（数学二，英语二，政治，专业课是C语言程序设计。。。），复试历年来好像是数据库和网络二选一。受知乎和王道论坛的毒害，目标定高一点\r\n\r\n<table border=\"1\">\r\n<tr>\r\n  <th>数学二</th>\r\n  <th>英语二</th>\r\n  <th>政治</th>\r\n  <th>专业课</th>\r\n  <th>总分</th>\r\n</tr>\r\n<tr>\r\n  <td>130</td>\r\n  <td>75</td>\r\n  <td>75</td>\r\n  <td>130</td>\r\n  <td>410</td>\r\n</tr>\r\n</table>\r\n\r\n感觉书都没看就定这么高的分数有点浮夸了，但也算是对自己的一个激励吧。我希望，至少得考个400分吧（努力评个一等奖学金，不然**12000/年**真的有点贵啊:upside_down:）\r\n\r\n不管怎么说，目标是定下来了，接下来的一年，将是我修身养性的一年，拥抱老年人的规律生活，不论最后结果如何，希望让自己感到满意且充实吧!:blush:\r\n\r\n博客还会不定期更新，嗯，真·不定期...',1,'post','publish','思索','生活',429,0,1,1,1),(20,'谈焦虑','discuss-anxious',1521789797,1526022952,'>Less insterests  \r\n>\r\n>More insterest',1,'post','publish','思索','手记',284,0,1,1,1),(21,'经典排序算法总结','sort-algorithm',1521079200,1526095259,'## 算法概述 ##\r\n### 算法分类 ###\r\n\r\n排序算法大体可分为两种：\r\n\r\n - 比较排序（非线性时间），时间复杂度**O(nlogn) ~ O(n^2)**，主要有：冒泡排序，选择排序，插入排序，归并排序，堆排序，快速排序等。\r\n - 非比较排序（线性时间），时间复杂度可以达到**O(n)**，主要有：计数排序，基数排序，桶排序等。\r\n\r\n### 算法复杂度 ###\r\n\r\n![复杂度][1]\r\n\r\n### 相关概念 ###\r\n稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。\r\n\r\n不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。\r\n\r\n时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。\r\n\r\n空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。\r\n\r\n## 比较排序 ##\r\n\r\n### 冒泡排序 ###\r\n```c \r\n#include <stdio.h>\r\n\r\n// 分类 -------------- 内部比较排序\r\n// 数据结构 ---------- 数组\r\n// 最差时间复杂度 ---- O(n^2)\r\n// 最优时间复杂度 ---- 如果能在内部循环第一次运行时,使用一个旗标来表示有无需要交换的可能,可以把最优时间复杂度降低到O(n)\r\n// 平均时间复杂度 ---- O(n^2)\r\n// 所需辅助空间 ------ O(1)\r\n// 稳定性 ------------ 稳定\r\n\r\nvoid Swap(int A[], int i, int j)\r\n{\r\n    int temp = A[i];\r\n    A[i] = A[j];\r\n    A[j] = temp;\r\n}\r\n\r\nvoid BubbleSort(int A[], int n)\r\n{\r\n    for (int j = 0; j < n - 1; j++)         // 每次最大元素就像气泡一样\"浮\"到数组的最后\r\n    {\r\n        for (int i = 0; i < n - 1 - j; i++) // 依次比较相邻的两个元素,使较大的那个向后移\r\n        {\r\n            if (A[i] > A[i + 1])            // 如果条件改成A[i] >= A[i + 1],则变为不稳定的排序算法\r\n            {\r\n                Swap(A, i, i + 1);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    int A[] = { 6, 5, 3, 1, 8, 7, 2, 4 };    // 从小到大冒泡排序\r\n    int n = sizeof(A) / sizeof(int);\r\n    BubbleSort(A, n);\r\n    printf(\"冒泡排序结果：\");\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        printf(\"%d \", A[i]);\r\n    }\r\n    printf(\"\\n\");\r\n    return 0;\r\n}\r\n``` \r\n\r\n鸡尾酒排序：也叫定向冒泡排序，是冒泡排序的一种改进。此算法与冒泡排序的不同处在于从低到高然后从高到低，而冒泡排序则仅从低到高去比较序列里的每个元素。他可以得到比冒泡排序稍微好一点的效能。\r\n```c\r\n#include <stdio.h>\r\n\r\n// 分类 -------------- 内部比较排序\r\n// 数据结构 ---------- 数组\r\n// 最差时间复杂度 ---- O(n^2)\r\n// 最优时间复杂度 ---- 如果序列在一开始已经大部分排序过的话,会接近O(n)\r\n// 平均时间复杂度 ---- O(n^2)\r\n// 所需辅助空间 ------ O(1)\r\n// 稳定性 ------------ 稳定\r\n\r\nvoid Swap(int A[], int i, int j)\r\n{\r\n    int temp = A[i];\r\n    A[i] = A[j];\r\n    A[j] = temp;\r\n}\r\n\r\nvoid CocktailSort(int A[], int n)\r\n{\r\n    int left = 0;                            // 初始化边界\r\n    int right = n - 1;\r\n    while (left < right)\r\n    {\r\n        for (int i = left; i < right; i++)   // 前半轮,将最大元素放到后面\r\n        {\r\n            if (A[i] > A[i + 1])\r\n            {\r\n                Swap(A, i, i + 1);\r\n            }\r\n        }\r\n        right--;\r\n        for (int i = right; i > left; i--)   // 后半轮,将最小元素放到前面\r\n        {\r\n            if (A[i - 1] > A[i])\r\n            {\r\n                Swap(A, i - 1, i);\r\n            }\r\n        }\r\n        left++;\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    int A[] = { 6, 5, 3, 1, 8, 7, 2, 4 };   // 从小到大定向冒泡排序\r\n    int n = sizeof(A) / sizeof(int);\r\n    CocktailSort(A, n);\r\n    printf(\"鸡尾酒排序结果：\");\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        printf(\"%d \", A[i]);\r\n    }\r\n    printf(\"\\n\");\r\n    return 0;\r\n}\r\n```\r\n### 选择排序 ###\r\n```c\r\n#include <stdio.h>\r\n\r\n// 分类 -------------- 内部比较排序\r\n// 数据结构 ---------- 数组\r\n// 最差时间复杂度 ---- O(n^2)\r\n// 最优时间复杂度 ---- O(n^2)\r\n// 平均时间复杂度 ---- O(n^2)\r\n// 所需辅助空间 ------ O(1)\r\n// 稳定性 ------------ 不稳定\r\n\r\nvoid Swap(int A[], int i, int j)\r\n{\r\n    int temp = A[i];\r\n    A[i] = A[j];\r\n    A[j] = temp;\r\n}\r\n\r\nvoid SelectionSort(int A[], int n)\r\n{\r\n    for (int i = 0; i < n - 1; i++)         // i为已排序序列的末尾\r\n    {\r\n        int min = i;\r\n        for (int j = i + 1; j < n; j++)     // 未排序序列\r\n        {\r\n            if (A[j] < A[min])              // 找出未排序序列中的最小值\r\n            {\r\n                min = j;\r\n            }\r\n        }\r\n        if (min != i)\r\n        {\r\n            Swap(A, min, i);    // 放到已排序序列的末尾，该操作很有可能把稳定性打乱，所以选择排序是不稳定的排序算法\r\n        }\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    int A[] = { 8, 5, 2, 6, 9, 3, 1, 4, 0, 7 }; // 从小到大选择排序\r\n    int n = sizeof(A) / sizeof(int);\r\n    SelectionSort(A, n);\r\n    printf(\"选择排序结果：\");\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        printf(\"%d \", A[i]);\r\n    }\r\n    printf(\"\\n\");\r\n    return 0;\r\n}\r\n```\r\n### 插入排序 ###\r\n插入排序是一种简单直观的排序算法。它的工作原理非常类似于我们抓扑克牌，对于未排序数据(右手抓到的牌)，在已排序序列(左手已经排好序的手牌)中从后向前扫描，找到相应位置并插入。\r\n```c\r\n#include <stdio.h>\r\n\r\n// 分类 ------------- 内部比较排序\r\n// 数据结构 ---------- 数组\r\n// 最差时间复杂度 ---- 最坏情况为输入序列是降序排列的,此时时间复杂度O(n^2)\r\n// 最优时间复杂度 ---- 最好情况为输入序列是升序排列的,此时时间复杂度O(n)\r\n// 平均时间复杂度 ---- O(n^2)\r\n// 所需辅助空间 ------ O(1)\r\n// 稳定性 ------------ 稳定\r\n\r\nvoid InsertionSort(int A[], int n)\r\n{\r\n    for (int i = 1; i < n; i++)         // 类似抓扑克牌排序\r\n    {\r\n        int get = A[i];                 // 右手抓到一张扑克牌\r\n        int j = i - 1;                  // 拿在左手上的牌总是排序好的\r\n        while (j >= 0 && A[j] > get)    // 将抓到的牌与手牌从右向左进行比较\r\n        {\r\n            A[j + 1] = A[j];            // 如果该手牌比抓到的牌大，就将其右移\r\n            j--;\r\n        }\r\n        A[j + 1] = get; // 直到该手牌比抓到的牌小(或二者相等)，将抓到的牌插入到该手牌右边(相等元素的相对次序未变，所以插入排序是稳定的)\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    int A[] = { 6, 5, 3, 1, 8, 7, 2, 4 };// 从小到大插入排序\r\n    int n = sizeof(A) / sizeof(int);\r\n    InsertionSort(A, n);\r\n    printf(\"插入排序结果：\");\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        printf(\"%d \", A[i]);\r\n    }\r\n    printf(\"\\n\");\r\n    return 0;\r\n}\r\n```\r\n二分插入排序：如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的次数，是对插入排序的改进。\r\n```c\r\n#include <stdio.h>\r\n\r\n// 分类 -------------- 内部比较排序\r\n// 数据结构 ---------- 数组\r\n// 最差时间复杂度 ---- O(n^2)\r\n// 最优时间复杂度 ---- O(nlogn)\r\n// 平均时间复杂度 ---- O(n^2)\r\n// 所需辅助空间 ------ O(1)\r\n// 稳定性 ------------ 稳定\r\n\r\nvoid InsertionSortDichotomy(int A[], int n)\r\n{\r\n    for (int i = 1; i < n; i++)\r\n    {\r\n        int get = A[i];                    // 右手抓到一张扑克牌\r\n        int left = 0;                    // 拿在左手上的牌总是排序好的，所以可以用二分法\r\n        int right = i - 1;                // 手牌左右边界进行初始化\r\n        while (left <= right)            // 采用二分法定位新牌的位置\r\n        {\r\n            int mid = (left + right) / 2;\r\n            if (A[mid] > get)\r\n                right = mid - 1;\r\n            else\r\n                left = mid + 1;\r\n        }\r\n        for (int j = i - 1; j >= left; j--)    // 将欲插入新牌位置右边的牌整体向右移动一个单位\r\n        {\r\n            A[j + 1] = A[j];\r\n        }\r\n        A[left] = get;                    // 将抓到的牌插入手牌\r\n    }\r\n}\r\n\r\n\r\nint main()\r\n{\r\n    int A[] = { 5, 2, 9, 4, 7, 6, 1, 3, 8 };// 从小到大二分插入排序\r\n    int n = sizeof(A) / sizeof(int);\r\n    InsertionSortDichotomy(A, n);\r\n    printf(\"二分插入排序结果：\");\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        printf(\"%d \", A[i]);\r\n    }\r\n    printf(\"\\n\");\r\n    return 0;\r\n}\r\n```\r\n希尔排序：也叫递减增量排序，是插入排序的一种更高效的改进版本。通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。\r\n```c\r\n#include <stdio.h>  \r\n\r\n// 分类 -------------- 内部比较排序\r\n// 数据结构 ---------- 数组\r\n// 最差时间复杂度 ---- 根据步长序列的不同而不同。已知最好的为O(n(logn)^2)\r\n// 最优时间复杂度 ---- O(n)\r\n// 平均时间复杂度 ---- 根据步长序列的不同而不同。\r\n// 所需辅助空间 ------ O(1)\r\n// 稳定性 ------------ 不稳定\r\n\r\nvoid ShellSort(int A[], int n)\r\n{\r\n    int h = 0;\r\n    while (h <= n)                          // 生成初始增量\r\n    {\r\n        h = 3 * h + 1;\r\n    }\r\n    while (h >= 1)\r\n    {\r\n        for (int i = h; i < n; i++)\r\n        {\r\n            int j = i - h;\r\n            int get = A[i];\r\n            while (j >= 0 && A[j] > get)\r\n            {\r\n                A[j + h] = A[j];\r\n                j = j - h;\r\n            }\r\n            A[j + h] = get;\r\n        }\r\n        h = (h - 1) / 3;                    // 递减增量\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    int A[] = { 5, 2, 9, 4, 7, 6, 1, 3, 8 };// 从小到大希尔排序\r\n    int n = sizeof(A) / sizeof(int);\r\n    ShellSort(A, n);\r\n    printf(\"希尔排序结果：\");\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        printf(\"%d \", A[i]);\r\n    }\r\n    printf(\"\\n\");\r\n    return 0;\r\n}\r\n```\r\n\r\n### 归并排序 ###\r\n归并排序的实现分为递归实现与非递归(迭代)实现。递归实现的归并排序是算法设计中分治策略的典型应用，我们将一个大问题分割成小问题分别解决，然后用所有小问题的答案来解决整个大问题。非递归(迭代)实现的归并排序首先进行是两两归并，然后四四归并，然后是八八归并，一直下去直到归并了整个数组。\r\n```c\r\n#include <stdio.h>\r\n#include <limits.h>\r\n\r\n// 分类 -------------- 内部比较排序\r\n// 数据结构 ---------- 数组\r\n// 最差时间复杂度 ---- O(nlogn)\r\n// 最优时间复杂度 ---- O(nlogn)\r\n// 平均时间复杂度 ---- O(nlogn)\r\n// 所需辅助空间 ------ O(n)\r\n// 稳定性 ------------ 稳定\r\n\r\n\r\nvoid Merge(int A[], int left, int mid, int right)// 合并两个已排好序的数组A[left...mid]和A[mid+1...right]\r\n{\r\n    int len = right - left + 1;\r\n    int *temp = new int[len];       // 辅助空间O(n)\r\n    int index = 0;\r\n    int i = left;                   // 前一数组的起始元素\r\n    int j = mid + 1;                // 后一数组的起始元素\r\n    while (i <= mid && j <= right)\r\n    {\r\n        temp[index++] = A[i] <= A[j] ? A[i++] : A[j++];  // 带等号保证归并排序的稳定性\r\n    }\r\n    while (i <= mid)\r\n    {\r\n        temp[index++] = A[i++];\r\n    }\r\n    while (j <= right)\r\n    {\r\n        temp[index++] = A[j++];\r\n    }\r\n    for (int k = 0; k < len; k++)\r\n    {\r\n        A[left++] = temp[k];\r\n    }\r\n}\r\n\r\nvoid MergeSortRecursion(int A[], int left, int right)    // 递归实现的归并排序(自顶向下)\r\n{\r\n    if (left == right)    // 当待排序的序列长度为1时，递归开始回溯，进行merge操作\r\n        return;\r\n    int mid = (left + right) / 2;\r\n    MergeSortRecursion(A, left, mid);\r\n    MergeSortRecursion(A, mid + 1, right);\r\n    Merge(A, left, mid, right);\r\n}\r\n\r\nvoid MergeSortIteration(int A[], int len)    // 非递归(迭代)实现的归并排序(自底向上)\r\n{\r\n    int left, mid, right;// 子数组索引,前一个为A[left...mid]，后一个子数组为A[mid+1...right]\r\n    for (int i = 1; i < len; i *= 2)        // 子数组的大小i初始为1，每轮翻倍\r\n    {\r\n        left = 0;\r\n        while (left + i < len)              // 后一个子数组存在(需要归并)\r\n        {\r\n            mid = left + i - 1;\r\n            right = mid + i < len ? mid + i : len - 1;// 后一个子数组大小可能不够\r\n            Merge(A, left, mid, right);\r\n            left = right + 1;               // 前一个子数组索引向后移动\r\n        }\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    int A1[] = { 6, 5, 3, 1, 8, 7, 2, 4 };      // 从小到大归并排序\r\n    int A2[] = { 6, 5, 3, 1, 8, 7, 2, 4 };\r\n    int n1 = sizeof(A1) / sizeof(int);\r\n    int n2 = sizeof(A2) / sizeof(int);\r\n    MergeSortRecursion(A1, 0, n1 - 1);          // 递归实现\r\n    MergeSortIteration(A2, n2);                 // 非递归实现\r\n    printf(\"递归实现的归并排序结果：\");\r\n    for (int i = 0; i < n1; i++)\r\n    {\r\n        printf(\"%d \", A1[i]);\r\n    }\r\n    printf(\"\\n\");\r\n    printf(\"非递归实现的归并排序结果：\");\r\n    for (int i = 0; i < n2; i++)\r\n    {\r\n        printf(\"%d \", A2[i]);\r\n    }\r\n    printf(\"\\n\");\r\n    return 0;\r\n}\r\n```\r\n### 堆排序 ###\r\n堆排序是指利用堆这种数据结构所设计的一种选择排序算法。堆是一种近似完全二叉树的结构（通常堆是通过一维数组来实现的），并满足性质：以最大堆（也叫大根堆、大顶堆）为例，其中父结点的值总是大于它的孩子节点。\r\n```c\r\n#include <stdio.h>\r\n\r\n// 分类 -------------- 内部比较排序\r\n// 数据结构 ---------- 数组\r\n// 最差时间复杂度 ---- O(nlogn)\r\n// 最优时间复杂度 ---- O(nlogn)\r\n// 平均时间复杂度 ---- O(nlogn)\r\n// 所需辅助空间 ------ O(1)\r\n// 稳定性 ------------ 不稳定\r\n\r\n\r\nvoid Swap(int A[], int i, int j)\r\n{\r\n    int temp = A[i];\r\n    A[i] = A[j];\r\n    A[j] = temp;\r\n}\r\n\r\nvoid Heapify(int A[], int i, int size)  // 从A[i]向下进行堆调整\r\n{\r\n    int left_child = 2 * i + 1;         // 左孩子索引\r\n    int right_child = 2 * i + 2;        // 右孩子索引\r\n    int max = i;                        // 选出当前结点与其左右孩子三者之中的最大值\r\n    if (left_child < size && A[left_child] > A[max])\r\n        max = left_child;\r\n    if (right_child < size && A[right_child] > A[max])\r\n        max = right_child;\r\n    if (max != i)\r\n    {\r\n        Swap(A, i, max);                // 把当前结点和它的最大(直接)子节点进行交换\r\n        Heapify(A, max, size);          // 递归调用，继续从当前结点向下进行堆调整\r\n    }\r\n}\r\n\r\nint BuildHeap(int A[], int n)           // 建堆，时间复杂度O(n)\r\n{\r\n    int heap_size = n;\r\n    for (int i = heap_size / 2 - 1; i >= 0; i--) // 从每一个非叶结点开始向下进行堆调整\r\n        Heapify(A, i, heap_size);\r\n    return heap_size;\r\n}\r\n\r\nvoid HeapSort(int A[], int n)\r\n{\r\n    int heap_size = BuildHeap(A, n);    // 建立一个最大堆\r\n    while (heap_size > 1)    　　　　　　 // 堆（无序区）元素个数大于1，未完成排序\r\n    {\r\n        // 将堆顶元素与堆的最后一个元素互换，并从堆中去掉最后一个元素\r\n        // 此处交换操作很有可能把后面元素的稳定性打乱，所以堆排序是不稳定的排序算法\r\n        Swap(A, 0, --heap_size);\r\n        Heapify(A, 0, heap_size);     // 从新的堆顶元素开始向下进行堆调整，时间复杂度O(logn)\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    int A[] = { 5, 2, 9, 4, 7, 6, 1, 3, 8 };// 从小到大堆排序\r\n    int n = sizeof(A) / sizeof(int);\r\n    HeapSort(A, n);\r\n    printf(\"堆排序结果：\");\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        printf(\"%d \", A[i]);\r\n    }\r\n    printf(\"\\n\");\r\n    return 0;\r\n}\r\n```\r\n ### 快速排序 ###\r\n快速排序使用分治策略来把一个序列分为两个子序列。\r\n```c\r\n#include <stdio.h>\r\n\r\n// 分类 ------------ 内部比较排序\r\n// 数据结构 --------- 数组\r\n// 最差时间复杂度 ---- 每次选取的基准都是最大（或最小）的元素，导致每次只划分出了一个分区，需要进行n-1次划分才能结束递归，时间复杂度为O(n^2)\r\n// 最优时间复杂度 ---- 每次选取的基准都是中位数，这样每次都均匀的划分出两个分区，只需要logn次划分就能结束递归，时间复杂度为O(nlogn)\r\n// 平均时间复杂度 ---- O(nlogn)\r\n// 所需辅助空间 ------ 主要是递归造成的栈空间的使用(用来保存left和right等局部变量)，取决于递归树的深度，一般为O(logn)，最差为O(n)       \r\n// 稳定性 ---------- 不稳定\r\n\r\nvoid Swap(int A[], int i, int j)\r\n{\r\n    int temp = A[i];\r\n    A[i] = A[j];\r\n    A[j] = temp;\r\n}\r\n\r\nint Partition(int A[], int left, int right)  // 划分函数\r\n{\r\n    int pivot = A[right];               // 这里每次都选择最后一个元素作为基准\r\n    int tail = left - 1;                // tail为小于基准的子数组最后一个元素的索引\r\n    for (int i = left; i < right; i++)  // 遍历基准以外的其他元素\r\n    {\r\n        if (A[i] <= pivot)              // 把小于等于基准的元素放到前一个子数组末尾\r\n        {\r\n            Swap(A, ++tail, i);\r\n        }\r\n    }\r\n    Swap(A, tail + 1, right);           // 最后把基准放到前一个子数组的后边，剩下的子数组既是大于基准的子数组\r\n                                        // 该操作很有可能把后面元素的稳定性打乱，所以快速排序是不稳定的排序算法\r\n    return tail + 1;                    // 返回基准的索引\r\n}\r\n\r\nvoid QuickSort(int A[], int left, int right)\r\n{\r\n    if (left >= right)\r\n        return;\r\n    int pivot_index = Partition(A, left, right); // 基准的索引\r\n    QuickSort(A, left, pivot_index - 1);\r\n    QuickSort(A, pivot_index + 1, right);\r\n}\r\n\r\nint main()\r\n{\r\n    int A[] = { 5, 2, 9, 4, 7, 6, 1, 3, 8 }; // 从小到大快速排序\r\n    int n = sizeof(A) / sizeof(int);\r\n    QuickSort(A, 0, n - 1);\r\n    printf(\"快速排序结果：\");\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        printf(\"%d \", A[i]);\r\n    }\r\n    printf(\"\\n\");\r\n    return 0;\r\n}\r\n```\r\n## 非比较排序 ##\r\n\r\n### 计数排序 ###\r\n计数排序用到一个额外的计数数组C，根据数组C来将原数组A中的元素排到正确的位置。\r\n```c\r\n#include<iostream>\r\nusing namespace std;\r\n\r\n// 分类 ------------ 内部非比较排序\r\n// 数据结构 --------- 数组\r\n// 最差时间复杂度 ---- O(n + k)\r\n// 最优时间复杂度 ---- O(n + k)\r\n// 平均时间复杂度 ---- O(n + k)\r\n// 所需辅助空间 ------ O(n + k)\r\n// 稳定性 ----------- 稳定\r\n\r\n\r\nconst int k = 100;   // 基数为100，排序[0,99]内的整数\r\nint C[k];            // 计数数组\r\n\r\nvoid CountingSort(int A[], int n)\r\n{\r\n    for (int i = 0; i < k; i++)   // 初始化，将数组C中的元素置0(此步骤可省略，整型数组元素默认值为0)\r\n    {\r\n        C[i] = 0;\r\n    }\r\n    for (int i = 0; i < n; i++)   // 使C[i]保存着等于i的元素个数\r\n    {\r\n        C[A[i]]++;\r\n    }\r\n    for (int i = 1; i < k; i++)   // 使C[i]保存着小于等于i的元素个数，排序后元素i就放在第C[i]个输出位置上\r\n    {\r\n        C[i] = C[i] + C[i - 1];\r\n    }\r\n    int *B = (int *)malloc((n) * sizeof(int));// 分配临时空间,长度为n，用来暂存中间数据\r\n    for (int i = n - 1; i >= 0; i--)    // 从后向前扫描保证计数排序的稳定性(重复元素相对次序不变)\r\n    {\r\n        B[--C[A[i]]] = A[i];      // 把每个元素A[i]放到它在输出数组B中的正确位置上\r\n                                  // 当再遇到重复元素时会被放在当前元素的前一个位置上保证计数排序的稳定性\r\n    }\r\n    for (int i = 0; i < n; i++)   // 把临时空间B中的数据拷贝回A\r\n    {\r\n        A[i] = B[i];\r\n    }\r\n    free(B);    // 释放临时空间 \r\n}\r\n\r\nint main()\r\n{\r\n    int A[] = { 15, 22, 19, 46, 27, 73, 1, 19, 8 };  // 针对计数排序设计的输入，每一个元素都在[0,100]上且有重复元素\r\n    int n = sizeof(A) / sizeof(int);\r\n    CountingSort(A, n);\r\n    printf(\"计数排序结果：\");\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        printf(\"%d \", A[i]);\r\n    }\r\n    printf(\"\\n\");\r\n    return 0;\r\n}\r\n```\r\n### 基数排序 ###\r\n将所有待比较正整数统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始进行基数为10的计数排序，一直到最高位计数排序完后，数列就变成一个有序序列（利用了计数排序的稳定性）。\r\n```c\r\n#include<iostream>\r\nusing namespace std;\r\n\r\n// 分类 ------------- 内部非比较排序\r\n// 数据结构 ---------- 数组\r\n// 最差时间复杂度 ---- O(n * dn)\r\n// 最优时间复杂度 ---- O(n * dn)\r\n// 平均时间复杂度 ---- O(n * dn)\r\n// 所需辅助空间 ------ O(n * dn)\r\n// 稳定性 ----------- 稳定\r\n\r\nconst int dn = 3;                // 待排序的元素为三位数及以下\r\nconst int k = 10;                // 基数为10，每一位的数字都是[0,9]内的整数\r\nint C[k];\r\n\r\nint GetDigit(int x, int d)          // 获得元素x的第d位数字\r\n{\r\n    int radix[] = { 1, 1, 10, 100 };// 最大为三位数，所以这里只要到百位就满足了\r\n    return (x / radix[d]) % 10;\r\n}\r\n\r\nvoid CountingSort(int A[], int n, int d)// 依据元素的第d位数字，对A数组进行计数排序\r\n{\r\n    for (int i = 0; i < k; i++)\r\n    {\r\n        C[i] = 0;\r\n    }\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        C[GetDigit(A[i], d)]++;\r\n    }\r\n    for (int i = 1; i < k; i++)\r\n    {\r\n        C[i] = C[i] + C[i - 1];\r\n    }\r\n    int *B = (int*)malloc(n * sizeof(int));\r\n    for (int i = n - 1; i >= 0; i--)\r\n    {\r\n        int dight = GetDigit(A[i], d);  // 元素A[i]当前位数字为dight   \r\n        B[--C[dight]] = A[i];           // 根据当前位数字，把每个元素A[i]放到它在输出数组B中的正确位置上\r\n        // 当再遇到当前位数字同为dight的元素时，会将其放在当前元素的前一个位置上保证计数排序的稳定性\r\n    }\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        A[i] = B[i];\r\n    }\r\n    free(B);\r\n}\r\n\r\nvoid LsdRadixSort(int A[], int n)     // 最低位优先基数排序\r\n{\r\n    for (int d = 1; d <= dn; d++)     // 从低位到高位\r\n        CountingSort(A, n, d);        // 依据第d位数字对A进行计数排序\r\n}\r\n\r\nint main()\r\n{\r\n    int A[] = { 20, 90, 64, 289, 998, 365, 852, 123, 789, 456 };// 针对基数排序设计的输入\r\n    int n = sizeof(A) / sizeof(int);\r\n    LsdRadixSort(A, n);\r\n    printf(\"基数排序结果：\");\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        printf(\"%d \", A[i]);\r\n    }\r\n    printf(\"\\n\");\r\n    return 0;\r\n}\r\n```\r\n### 桶排序 ###\r\n桶排序也叫箱排序。工作的原理是将数组元素映射到有限数量个桶里，利用计数排序可以定位桶的边界，每个桶再各自进行桶内排序（使用其它排序算法或以递归方式继续使用桶排序）。\r\n```c\r\n#include<iostream>\r\nusing namespace std;\r\n\r\n// 分类 ------------- 内部非比较排序\r\n// 数据结构 --------- 数组\r\n// 最差时间复杂度 ---- O(nlogn)或O(n^2)，只有一个桶，取决于桶内排序方式\r\n// 最优时间复杂度 ---- O(n)，每个元素占一个桶\r\n// 平均时间复杂度 ---- O(n)，保证各个桶内元素个数均匀即可\r\n// 所需辅助空间 ------ O(n + bn)\r\n// 稳定性 ----------- 稳定\r\n\r\n/* 本程序用数组模拟桶 */\r\nconst int bn = 5;    // 这里排序[0,49]的元素，使用5个桶就够了，也可以根据输入动态确定桶的数量\r\nint C[bn];           // 计数数组，存放桶的边界信息\r\n\r\nvoid InsertionSort(int A[], int left, int right)\r\n{\r\n    for (int i = left + 1; i <= right; i++)  // 从第二张牌开始抓，直到最后一张牌\r\n    {\r\n        int get = A[i];\r\n        int j = i - 1;\r\n        while (j >= left && A[j] > get)\r\n        {\r\n            A[j + 1] = A[j];\r\n            j--;\r\n        }\r\n        A[j + 1] = get;\r\n    }\r\n}\r\n\r\nint MapToBucket(int x)\r\n{\r\n    return x / 10;    // 映射函数f(x)，作用相当于快排中的Partition，把大量数据分割成基本有序的数据块\r\n}\r\n\r\nvoid CountingSort(int A[], int n)\r\n{\r\n    for (int i = 0; i < bn; i++)\r\n    {\r\n        C[i] = 0;\r\n    }\r\n    for (int i = 0; i < n; i++)     // 使C[i]保存着i号桶中元素的个数\r\n    {\r\n        C[MapToBucket(A[i])]++;\r\n    }\r\n    for (int i = 1; i < bn; i++)    // 定位桶边界：初始时，C[i]-1为i号桶最后一个元素的位置\r\n    {\r\n        C[i] = C[i] + C[i - 1];\r\n    }\r\n    int *B = (int *)malloc((n) * sizeof(int));\r\n    for (int i = n - 1; i >= 0; i--)// 从后向前扫描保证计数排序的稳定性(重复元素相对次序不变)\r\n    {\r\n        int b = MapToBucket(A[i]);  // 元素A[i]位于b号桶\r\n        B[--C[b]] = A[i];           // 把每个元素A[i]放到它在输出数组B中的正确位置上\r\n                                    // 桶的边界被更新：C[b]为b号桶第一个元素的位置\r\n    }\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        A[i] = B[i];\r\n    }\r\n    free(B);\r\n}\r\n\r\nvoid BucketSort(int A[], int n)\r\n{\r\n    CountingSort(A, n);          // 利用计数排序确定各个桶的边界（分桶）\r\n    for (int i = 0; i < bn; i++) // 对每一个桶中的元素应用插入排序\r\n    {\r\n        int left = C[i];         // C[i]为i号桶第一个元素的位置\r\n        int right = (i == bn - 1 ? n - 1 : C[i + 1] - 1);// C[i+1]-1为i号桶最后一个元素的位置\r\n        if (left < right)        // 对元素个数大于1的桶进行桶内插入排序\r\n            InsertionSort(A, left, right);\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    int A[] = { 29, 25, 3, 49, 9, 37, 21, 43 };// 针对桶排序设计的输入\r\n    int n = sizeof(A) / sizeof(int);\r\n    BucketSort(A, n);\r\n    printf(\"桶排序结果：\");\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        printf(\"%d \", A[i]);\r\n    }\r\n    printf(\"\\n\");\r\n    return 0;\r\n}\r\n```\r\n\r\n  [1]: http://plover.space/upload/2018/05/uhhr3ei678i5uo3mlea51mp3ev.png',1,'post','publish','数据结构,排序','编程',154,0,1,1,1),(22,'哈夫曼树与哈夫曼编码','huffman-coding',1522544400,1526100300,'## Definition ##\r\n哈夫曼树又称最优二叉树，是一种带权路径长度最短的二叉树。所谓树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的路径长度，树的路径长度是从树根到每一结点的路径长度之和。\r\n\r\n哈夫曼编码算法是基于二叉树构建编码压缩结构的，它是数据压缩中经典的一种算法。算法根据文本字符出现的频率，重新对字符进行编码。因为为了缩短编码的长度，我们自然希望频率越高的词，编码越短，这样最终才能最大化压缩存储文本数据的空间。 \r\n## Construct ##\r\n\r\n - 哈夫曼树的构造  \r\n1.根据给定的n个权值{w1,w2,…,wn}构成二叉树集合F={T1,T2,…,Tn},其中每棵二叉树Ti中只有一个带权为wi的根结点,其左右子树为空.  \r\n2.在F中选取两棵根结点权值最小的树作为左右子树构造一棵新的二叉树,且置新的二叉树的根结点的权值为左右子树根结点的权值之和.  \r\n3.在F中删除这两棵树,同时将新的二叉树加入F中.  \r\n4.重复2、3,直到F只含有一棵树为止.(得到哈夫曼树)  \r\n![huffman tree][1]\r\n\r\n - 哈夫曼编码算法\r\n```c\r\n/*-------------------------------------------------------------------------\r\n * 实现过程：着先通过 HuffmanTree() 函数构造哈夫曼树，然后在主函数 main()中\r\n *           自底向上开始(也就是从数组序号为零的结点开始)向上层层判断，若在\r\n *           父结点左侧，则置码为 0,若在右侧,则置码为 1。最后输出生成的编码。\r\n *------------------------------------------------------------------------*/\r\n#include <stdio.h>\r\n\r\n#define MAXBIT      100\r\n#define MAXVALUE  10000\r\n#define MAXLEAF     30\r\n#define MAXNODE    MAXLEAF*2 -1\r\n\r\ntypedef struct \r\n{\r\n    int bit[MAXBIT];\r\n    int start;\r\n} HCodeType;        /* 编码结构体 */\r\ntypedef struct\r\n{\r\n    int weight;\r\n    int parent;\r\n    int lchild;\r\n    int rchild;\r\n} HNodeType;        /* 结点结构体 */\r\n\r\n/* 构造一颗哈夫曼树 */\r\nvoid HuffmanTree (HNodeType HuffNode[MAXNODE],  int n)\r\n{ \r\n    /* i、j： 循环变量，m1、m2：构造哈夫曼树不同过程中两个最小权值结点的权值，\r\n        x1、x2：构造哈夫曼树不同过程中两个最小权值结点在数组中的序号。*/\r\n    int i, j, m1, m2, x1, x2;\r\n    /* 初始化存放哈夫曼树数组 HuffNode[] 中的结点 */\r\n    for (i=0; i<2*n-1; i++)\r\n    {\r\n        HuffNode[i].weight = 0;\r\n        HuffNode[i].parent =-1;\r\n        HuffNode[i].lchild =-1;\r\n        HuffNode[i].lchild =-1;\r\n    } /* end for */\r\n\r\n    /* 输入 n 个叶子结点的权值 */\r\n    for (i=0; i<n; i++)\r\n    {\r\n        printf (\"Please input weight of leaf node %d: \\n\", i);\r\n        scanf (\"%d\", &HuffNode[i].weight);\r\n    } /* end for */\r\n\r\n    /* 循环构造 Huffman 树 */\r\n    for (i=0; i<n-1; i++)\r\n    {\r\n        m1=m2=MAXVALUE;     /* m1、m2中存放两个无父结点且结点权值最小的两个结点 */\r\n        x1=x2=0;\r\n        /* 找出所有结点中权值最小、无父结点的两个结点，并合并之为一颗二叉树 */\r\n        for (j=0; j<n+i; j++)\r\n        {\r\n            if (HuffNode[j].weight < m1 && HuffNode[j].parent==-1)\r\n            {\r\n                m2=m1; \r\n                x2=x1; \r\n                m1=HuffNode[j].weight;\r\n                x1=j;\r\n            }\r\n            else if (HuffNode[j].weight < m2 && HuffNode[j].parent==-1)\r\n            {\r\n                m2=HuffNode[j].weight;\r\n                x2=j;\r\n            }\r\n        } /* end for */\r\n            /* 设置找到的两个子结点 x1、x2 的父结点信息 */\r\n        HuffNode[x1].parent  = n+i;\r\n        HuffNode[x2].parent  = n+i;\r\n        HuffNode[n+i].weight = HuffNode[x1].weight + HuffNode[x2].weight;\r\n        HuffNode[n+i].lchild = x1;\r\n        HuffNode[n+i].rchild = x2;\r\n\r\n        printf (\"x1.weight and x2.weight in round %d: %d, %d\\n\", i+1, HuffNode[x1].weight, HuffNode[x2].weight);  /* 用于测试 */\r\n        printf (\"\\n\");\r\n    } /* end for */\r\n} /* end HuffmanTree */\r\n\r\nint main(void)\r\n{\r\n    HNodeType HuffNode[MAXNODE];            /* 定义一个结点结构体数组 */\r\n    HCodeType HuffCode[MAXLEAF],  cd;       /* 定义一个编码结构体数组， 同时定义一个临时变量来存放求解编码时的信息 */\r\n    int i, j, c, p, n;\r\n    printf (\"Please input n:\\n\");\r\n    scanf (\"%d\", &n);\r\n    HuffmanTree (HuffNode, n);\r\n    \r\n    for (i=0; i < n; i++)\r\n    {\r\n        cd.start = n-1;\r\n        c = i;\r\n        p = HuffNode[c].parent;\r\n        while (p != -1)   /* 父结点存在 */\r\n        {\r\n            if (HuffNode[p].lchild == c)\r\n                cd.bit[cd.start] = 0;\r\n            else\r\n                cd.bit[cd.start] = 1;\r\n            cd.start--;        /* 求编码的低一位 */\r\n            c=p;                    \r\n            p=HuffNode[c].parent;    /* 设置下一循环条件 */\r\n        } /* end while */\r\n        \r\n        /* 保存求出的每个叶结点的哈夫曼编码和编码的起始位 */\r\n        for (j=cd.start+1; j<n; j++)\r\n        { HuffCode[i].bit[j] = cd.bit[j];}\r\n        HuffCode[i].start = cd.start;\r\n    } /* end for */\r\n    \r\n    /* 输出已保存好的所有存在编码的哈夫曼编码 */\r\n    for (i=0; i<n; i++)\r\n    {\r\n        printf (\"%d \'s Huffman code is: \", i);\r\n        for (j=HuffCode[i].start+1; j < n; j++)\r\n        {\r\n            printf (\"%d\", HuffCode[i].bit[j]);\r\n        }\r\n        printf (\"\\n\");\r\n    }\r\n    getch();\r\n    return 0;\r\n}\r\n```\r\n\r\n\r\n  [1]: http://plover.space/upload/2018/05/rekgrv9qdigfhqm0ei6j1ulrou.png',1,'post','publish','数据结构,树','编程',233,0,1,1,1),(23,'邻接矩阵、领接表与十字链表','map-store',1523179800,1526102019,'## 图的抽象数据类型 ##\r\n```c\r\nADT 图(Graph)\r\nData\r\n    顶点的有穷非空集合和边的集合。\r\nOperation\r\n    CreateGraph(*G, V, VR): 按照顶点集V和边弧集VR的定义构造图G。\r\n    DestroyGraph(*G):       图G存在则销毁。\r\n    LocateVex(G, u):        若图G中存在顶点u，则返回图中的位置。\r\n    GetVex(G, v):           返回图G中顶点v的值。\r\n    PutVex(G, v, value):    将图G中顶点v赋值value。\r\n    FirstAdjVex(G, *v):     返回顶点v的一个邻接顶点，若顶点在G中无邻接顶点返回空。\r\n    NextAdjVex(G, v, *w):   返回顶点v相对于顶点w的下一个邻接顶点，\r\n                            若w是v的最后一个邻接点则返回“空”。\r\n    InsertVex(*G, v):       在图G中增添新顶点v。\r\n    DeleteVex(*G, v):       删除图G中顶点v及其相关的弧。\r\n    InsertArc(*G, v, w):    在图G中增添弧<v,w>，若G是无向图，还需要增添对称弧<w,v>。\r\n    DeleteArc(*G, v, w):    在图G中删除弧<v,w>，若G是无向图，则还删除对称弧<w,v>。\r\n    DFSTraverse(G):         对图G中进行深度优先遍历，在遍历过程对每个顶点调用。\r\n    HFSTraverse(G):         对图G中进行广度优先遍历，在遍历过程对每个顶点调用。\r\nendADT\r\n```\r\n## 图的存储结构 ##\r\n### 邻接矩阵 ###\r\n图的邻接矩阵（Adjacency Matrix）存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。\r\n\r\n - 无向图的邻接矩阵  \r\n![无向图邻接矩阵][1]  \r\n根据这个矩阵，要知道某个顶点的度，其实就是这个顶点vi在邻接矩阵中第i行（或第i列）的元素之和。比如顶点v1的度就是1+0+1+0=2。求顶点vi的所有邻接点就是将矩阵中第i行元素扫描一遍，arc[i][j]为1就是邻接点。\r\n - 有向图的邻接矩阵\r\n![有向图的邻接矩阵][2]  \r\n有向图讲究入度与出度，顶点v1的入度为1，正好是第v1列各数之和。顶点v1的出度为2，即第v1行的各数之和。 \r\n### 邻接表 ###\r\n邻接矩阵对于边数相对顶点较少的图，存在对存储空间的极大浪费的现象。因此这种存储方式对于稀疏图来说不是很合适。借鉴于线性表的解决方案，可以考虑对边或弧使用链式存储的方式来避免空间浪费的问题。使用数组与链表相结合的存储方式，就诞生了邻接表（Ad-jacency List）。\r\n邻接表的处理办法是这样:   \r\n - 图中顶点用一个一维数组存储，当然，顶点也可以用单链表来存储，不过数组可以较容易地读取顶点信息，更加方便。另外，对于顶点数组中，每个数据元素还需要存储指向第一个邻接点的指针，以便于查找该顶点的边信息。   \r\n - 图中每个顶点vi的所有邻接点构成一个线性表，由于邻接点的个数不定，所以用单链表存储，无向图称为顶点vi的边表，有向图则称为顶点vi作为弧尾的出边表。  \r\n![邻接表][3]  \r\n顶点表的各个结点由data和firstedge两个域表示，data是数据域，存储顶点的信息，firstedge是指针域，指向边表的第一个结点，即此顶点的第一个邻接点。边表结点由adjvex和next两个域组成。adjvex是邻接点域，存储某顶点的邻接点在顶点表中的下标，next则存储指向边表中下一个结点的指针。比如v1顶点与v0、v2互为邻接点，则在v1的边表中，adjvex分别为v0的0和v2的2。  \r\n - 有向图的邻接表\r\n![有向图邻接表][4]  \r\n有向图由于有方向，以顶点为弧尾来存储边表，这样就很容易就可以得到每个顶点的出度。但也有时为了便于确定顶点的入度或以顶点为弧头的弧，可以建立一个有向图的逆邻接表，即对每个顶点vi都建立一个链接为vi为弧头的表。如上图的第三幅图所示。\r\n### 十字链表 ###\r\n对于有向图来说，邻接表是有缺陷的。关心了出度问题，想了解入度就必须要遍历整个图才能知道，反之，逆邻接表解决了入度却不了解出度的情况。把邻接表与逆邻接表结合起来，这就是十字链表（Orthogonal List）。\r\n![十字链表][5]  \r\n顶点表结点结构：data —— firstin(入边表头指针) —— firstout(出边表头指针)   \r\n边表结点结构：其中tailvex是指弧起点在顶点表的下标，headvex是指弧终点在顶点表中的下标，headlink是指入边表指针域，指向终点相同的下一条边，taillink是指边表指针域，指向起点相同的下一条边。如果是网，还可以再增加一个weight域来存储权值。  \r\n虚线箭头其实就是此图的逆邻接表的表示。对于v0来说，它有两个顶点v1和v2的入边。因此v0的firstin指向顶点v1的边表结点中headvex为0的结点，如上图中的①。接着由入边结点的headlink指向下一个入边顶点v2，如图中的②。对于顶点v1，它有一个入边顶点v2，所以它的firstin指向顶点v2的边表结点中headvex为1的结点，如图中的③。顶点v2和v3也是同样有一个入边顶点，如图中④和⑤。  \r\n\r\n十字链表的好处就是因为把邻接表和逆邻接表整合在了一起，这样既容易找到以vi为尾的弧，也容易找到以vi为头的弧，因而容易求得顶点的出度和入度。而且它除了结构复杂一点外，其实创建图算法的时间复杂度是和邻接表相同的，因此，在有向图的应用中，十字链表是非常好的数据结构模型。  \r\n\r\n\r\n  [1]: http://plover.space/upload/2018/05/4jmcha5650jk1rkl83edni7ns1.jpg\r\n  [2]: http://plover.space/upload/2018/05/q6qpdlrkaehlnrqhum30bacrrr.jpg\r\n  [3]: http://plover.space/upload/2018/05/7pcgojj3d0gkpr50t1a48ssqe7.jpg\r\n  [4]: http://plover.space/upload/2018/05/tjih3b1o7sjdmrg828jvvkgptf.jpg\r\n  [5]: http://plover.space/upload/2018/05/7j4m382bs2hlloh5fha476qs7h.jpg',1,'post','publish','数据结构,图','编程',191,0,1,1,1),(24,'经典查找算法总结','search-algorithm',1521531000,1526106111,'### 顺序查找 ###\r\n```c\r\nint SequenceSearch(int a[], int value, int n)\r\n{\r\n    int i;\r\n    for(i=0; i<n; i++)\r\n        if(a[i]==value)\r\n            return i;\r\n    return -1;\r\n}\r\n```\r\n### 二分查找 ###\r\n```c\r\n//非递归版本\r\nint BinarySearch1(int a[], int value, int n)\r\n{\r\n    int low, high, mid;\r\n    low = 0;\r\n    high = n-1;\r\n    while(low<=high)\r\n    {\r\n        mid = (low+high)/2;\r\n        if(a[mid]==value)\r\n            return mid;\r\n        if(a[mid]>value)\r\n            high = mid-1;\r\n        if(a[mid]<value)\r\n            low = mid+1;\r\n    }\r\n    return -1;\r\n}\r\n\r\n//递归版本\r\nint BinarySearch2(int a[], int value, int low, int high)\r\n{\r\n    int mid = low+(high-low)/2;\r\n    if(a[mid]==value)\r\n        return mid;\r\n    if(a[mid]>value)\r\n        return BinarySearch2(a, value, low, mid-1);\r\n    if(a[mid]<value)\r\n        return BinarySearch2(a, value, mid+1, high);\r\n}\r\n```\r\n### 插值查找 ###\r\n基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。\r\n```c\r\n//插值查找\r\nint InsertionSearch(int a[], int value, int low, int high)\r\n{\r\n    int mid = low+(value-a[low])/(a[high]-a[low])*(high-low);\r\n    if(a[mid]==value)\r\n        return mid;\r\n    if(a[mid]>value)\r\n        return InsertionSearch(a, value, low, mid-1);\r\n    if(a[mid]<value)\r\n        return InsertionSearch(a, value, mid+1, high);\r\n}\r\n```\r\n### 斐波那契查找 ###\r\n是二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率。\r\n```c\r\n/*构造一个斐波那契数组*/ \r\nvoid Fibonacci(int * F)\r\n{\r\n    F[0]=0;\r\n    F[1]=1;\r\n    for(int i=2;i<max_size;++i)\r\n        F[i]=F[i-1]+F[i-2];\r\n}\r\n\r\n/*定义斐波那契查找法*/  \r\nint FibonacciSearch(int *a, int n, int key)  //a为要查找的数组,n为要查找的数组长度,key为要查找的关键字\r\n{\r\n  int low=0;\r\n  int high=n-1;\r\n  \r\n  int F[max_size];\r\n  Fibonacci(F);//构造一个斐波那契数组F \r\n\r\n  int k=0;\r\n  while(n>F[k]-1)//计算n位于斐波那契数列的位置\r\n      ++k;\r\n\r\n  int  * temp;//将数组a扩展到F[k]-1的长度\r\n  temp=new int [F[k]-1];\r\n  memcpy(temp,a,n*sizeof(int));\r\n\r\n  for(int i=n;i<F[k]-1;++i)\r\n     temp[i]=a[n-1];\r\n  \r\n  while(low<=high)\r\n  {\r\n    int mid=low+F[k-1]-1;\r\n    if(key<temp[mid])\r\n    {\r\n      high=mid-1;\r\n      k-=1;\r\n    }\r\n    else if(key>temp[mid])\r\n    {\r\n     low=mid+1;\r\n     k-=2;\r\n    }\r\n    else\r\n    {\r\n       if(mid<n)\r\n           return mid; //若相等则说明mid即为查找到的位置\r\n       else\r\n           return n-1; //若mid>=n则说明是扩展的数值,返回n-1\r\n    }\r\n  }  \r\n  delete [] temp;\r\n  return -1;\r\n}\r\n```\r\n### 树表查找 ###\r\n\r\n - 二叉查找树：先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围。二叉查找树定义如下：   \r\n1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；  \r\n2）若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；  \r\n3）任意节点的左、右子树也分别为二叉查找树。  \r\n二叉查找树性质：对二叉查找树进行中序遍历，即可得到有序的数列。  \r\n  \r\n  \r\n - 平衡查找树之2-3树：和二叉树不一样，2-3树运行每个节点保存1个或者两个的值。对于普通的2节点(2-node)，他保存1个key和左右两个自己点。对应3节点(3-node)，保存两个Key，2-3查找树的定义如下：  \r\n1）要么为空，要么：  \r\n2）对于2节点，该节点保存一个key及对应value，以及两个指向左右节点的节点，左节点也是一个2-3节点，所有的值都比key要小，右节点也是一个2-3节点，所有的值比key要大。  \r\n3）对于3节点，该节点保存两个key及对应value，以及三个指向左中右的节点。左节点也是一个2-3节点，所有的值均比两个key中的最小的key还要小；中间节点也是一个2-3节点，中间节点的key值在两个跟节点key值之间；右节点也是一个2-3节点，节点的所有key值比两个key中的最大的key还要大。  \r\n![2-3树][1]  \r\n2-3树的性质：  \r\n1）如果中序遍历2-3查找树，就可以得到排好序的序列；  \r\n2）在一个完全平衡的2-3查找树中，根节点到每一个为空节点的距离都相同。（这也是平衡树中“平衡”一词的概念）  \r\n - 平衡查找树之红黑树：2-3树的简单实现。红黑树的思想就是对2-3查找树进行编码，尤其是对2-3查找树中的3-nodes节点添加额外的信息。红黑树中将节点之间的链接分为两种不同类型，红色链接，他用来链接两个2-nodes节点来表示一个3-nodes节点。黑色链接用来链接普通的2-3节点。特别的，使用红色链接的两个2-nodes来表示一个3-nodes节点，并且向左倾斜，即一个2-node是另一个2-node的左子节点。这种做法的好处是查找的时候不用做任何修改，和普通的二叉查找树相同。  \r\n![红黑树][2]  \r\n下图可以看到红黑树其实是2-3树的另外一种表现形式：如果我们将红色的连线水平绘制，那么他链接的两个2-node节点就是2-3树中的一个3-node节点了。  \r\n![展开红黑树][3]  \r\n - B树和B+树：B树是2-3树的一种扩展，他允许一个节点有多于2个的元素。B和B+树的区别在于，B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。  \r\nB树：  \r\n![B树][4]  \r\nB+树：    \r\n![B+树][5]  \r\nB+ 树的优点在于：  \r\n由于B+树在内部节点上不好含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子几点上关联的数据也具有更好的缓存命中率。  \r\nB+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。  \r\n但是B树也有优点，其优点在于，由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。  \r\n### 分块查找 ###\r\n又称索引顺序查找，它是顺序查找的一种改进方法。  \r\n算法思想：将n个数据元素\"按块有序\"划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须\"按块有序\"；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，……  \r\n算法流程：  \r\nstep1 先选取各块中的最大关键字构成一个索引表；  \r\nstep2 查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找。  \r\n### 哈希查找 ###\r\n设计一个函数（哈希函数， 也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标）相对应，于是用这个数组单元来存储这个元素。但是，不能够保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了\"冲突\"。总的来说，\"直接定址\"与\"解决冲突\"是哈希表的两大特点。而解决冲突则是我们重点关注的地方。  \r\n - 开放定址法  \r\n开放地执法有一个公式:Hi=(H(key)+di) MOD m i=1,2,...,k(k<=m-1)\r\n其中，m为哈希表的表长。di 是产生冲突的时候的增量序列。如果di值可能为1,2,3,...m-1，称线性探测再散列。\r\n如果di取1，则每次冲突之后，向后移动1个位置.如果di取值可能为1,-1,2,-2,4,-4,9,-9,16,-16,...k*k,-k*k(k<=m/2) \r\n称二次探测再散列。如果di取值可能为伪随机数列。称伪随机探测再散列。  \r\n - 再散列法  \r\n当发生冲突时，使用第二个、第三个、哈希函数计算地址，直到无冲突时。缺点：计算时间增加。  \r\n - 拉链法  \r\n将所有关键字为同义词的记录存储在同一线性链表中。如下：\r\n![链式][6]\r\n - 建立公共溢区  \r\n假设哈希函数的值域为[0,m-1],则设向量HashTable[0..m-1]为基本表，另外设立存储空间向量OverTable[0..v]用以存储发生冲突的记录。\r\n\r\n\r\n  [1]: http://plover.space/upload/2018/05/3e618nomf0ggprqppm3fe15jv4.png\r\n  [2]: http://plover.space/upload/2018/05/51p6trc5l2hedralemrqbmcg9g.png\r\n  [3]: http://plover.space/upload/2018/05/5hqe87h636g4vqh2khfebncbbk.png\r\n  [4]: http://plover.space/upload/2018/05/rbcq8o2bf8gl1qe8k6nrcavrvh.png\r\n  [5]: http://plover.space/upload/2018/05/4l55dn2d1ih1uoec2spe43bf3a.png\r\n  [6]: http://plover.space/upload/2018/05/23n2i21dq0g7crcu3hsr6uvaps.jpg',1,'post','publish','数据结构,查找','编程',141,0,1,1,1),(25,'森林、树、二叉树的相互转换','forest-tree-binarytree',1523764800,1526107008,'### 森林转二叉树 ###\r\n转换规则：兄弟相连，长兄为父，孩子靠左。  \r\n\r\n 1. 把每棵树转换为二叉树\r\n 2. 第一棵二叉树不动，从第二棵二叉树开始，一次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来  \r\n![森林转二叉树][1]  \r\n### 树转二叉树 ###\r\n 1. 加线。在所有的兄弟结点之间加一条线  \r\n 2. 去线。树中的每个结点，只保留它与第一个孩子结点的连线，删除其他孩子结点之间的连线  \r\n 3. 调整。以树的根结点为轴心，将整个树调节一下（第一个孩子是结点的左孩子，兄弟转过来的孩子是结点的右孩子）  \r\n![树转二叉树][2]  \r\n### 二叉树转树 ###\r\n 1. 加线。若某结点X的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子的右孩子结点。。。都作为结点X的孩子。将结点X与这些右孩子结点用线连接起来。\r\n 2. 去线。删除原二叉树中所有结点与其右孩子结点的连线。\r\n 3. 层次调整。  \r\n![二叉树转树][3]  \r\n### 二叉树转森林 ###\r\n加入一棵二叉树的根节点有右孩子，则这棵二叉树能够转换为森林，否则转换为一棵树。\r\n 1. 从根节点开始，若右孩子存在，则把与右孩子结点的连线删除。再查看分离后的二叉树，若其根节点的右孩子存在，则连续删除。直到所有这些根结点与右孩子的连线都删除为止。  \r\n 2. 将每棵分离后的二叉树转换为树。\r\n![二叉树转森林][4]\r\n\r\n\r\n  [1]: http://plover.space/upload/2018/05/ul9p61c8u2h5sp3bkb2ce6bet4.png\r\n  [2]: http://plover.space/upload/2018/05/ukooi2devkj82rb3p57rcj2tni.png\r\n  [3]: http://plover.space/upload/2018/05/65jbm746r6ge3qpm2b228hsdam.png\r\n  [4]: http://plover.space/upload/2018/05/2d1fpu7pvmghbqjm6lfovp4ngu.png',1,'post','publish','数据结构,树','编程',151,0,1,1,1),(26,'KMP算法','kmp-search',1522302600,1526111677,'假设现在我们面临这样一个问题：有一个文本串S，和一个模式串P，现在要查找P在S中的位置，怎么查找呢？  \r\n 如果用暴力匹配的思路，并假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置，则有：  \r\n - 如果当前字符匹配成功（即S[i] == P[j]），则i++，j++，继续匹配下一个字符；  \r\n - 如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。  \r\n  \r\n    \r\n大牛们是无法忍受“暴力破解”这种低效的手段的，于是他们三个研究出了KMP算法。其思想是：“利用已经部分匹配这个有效信息，保持i指针不回溯，通过修改j指针，让模式串尽量地移动到有效的位置。  \r\n所以，整个KMP的重点就在于当某一个字符与主串不匹配时，我们应该知道j指针要移动到哪？  \r\n好，接下来就是重点了，怎么求这个回溯距离（这些）k呢？因为在P的每一个位置都可能发生不匹配，也就是说我们要计算每一个位置j对应的k，所以用一个数组next来保存。   \r\n\r\n```java\r\n//流传最广的next数组求法\r\npublic static int[] getNext(String ps) {\r\n\r\n    char[] p = ps.toCharArray();\r\n\r\n    int[] next = new int[p.length];\r\n\r\n    next[0] = -1;\r\n\r\n    int j = 0;\r\n\r\n    int k = -1;\r\n\r\n    while (j < p.length - 1) {\r\n\r\n       if (k == -1 || p[j] == p[k]) {\r\n\r\n           next[++j] = ++k;\r\n\r\n       } else {\r\n\r\n           k = next[k];\r\n\r\n       }\r\n\r\n    }\r\n\r\n    return next;\r\n\r\n}\r\n\r\npublic static int KMP(String ts, String ps) {\r\n\r\n    char[] t = ts.toCharArray();\r\n\r\n    char[] p = ps.toCharArray();\r\n\r\n    int i = 0; // 主串的位置\r\n\r\n    int j = 0; // 模式串的位置\r\n\r\n    int[] next = getNext(ps);\r\n\r\n    while (i < t.length && j < p.length) {\r\n\r\n       if (j == -1 || t[i] == p[j]) { // 当j为-1时，要移动的是i，当然j也要归0\r\n\r\n           i++;\r\n\r\n           j++;\r\n\r\n       } else {\r\n\r\n           // i不需要回溯了\r\n\r\n           // i = i - j + 1;\r\n\r\n           j = next[j]; // j回到指定位置\r\n\r\n       }\r\n\r\n    }\r\n\r\n    if (j == p.length) {\r\n\r\n       return i - j;\r\n\r\n    } else {\r\n\r\n       return -1;\r\n\r\n    }\r\n\r\n}\r\n\r\n//优化后的next数组求法\r\npublic static int[] getNext(String ps) {\r\n\r\n    char[] p = ps.toCharArray();\r\n\r\n    int[] next = new int[p.length];\r\n\r\n    next[0] = -1;\r\n\r\n    int j = 0;\r\n\r\n    int k = -1;\r\n\r\n    while (j < p.length - 1) {\r\n\r\n       if (k == -1 || p[j] == p[k]) {\r\n\r\n           if (p[++j] == p[++k]) { // 当两个字符相等时要跳过\r\n\r\n              next[j] = next[k];\r\n\r\n           } else {\r\n\r\n              next[j] = k;\r\n\r\n           }\r\n\r\n       } else {\r\n\r\n           k = next[k];\r\n\r\n       }\r\n\r\n    }\r\n\r\n    return next;\r\n\r\n}\r\n```\r\n\r\n',1,'post','publish','数据结构,串,查找','编程',170,0,1,1,1),(27,'背包问题','bag-price',1524310200,1526113878,'### 0-1背包问题 ###\r\n有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。  \r\n基本思路：这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。  \r\n用子问题定义状态：即f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：  \r\n\r\n> f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}\r\n\r\n这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的。所以有必要将它详细解释一下：“将前i件物品放入容量为v的背包中”这个子问题，若只考虑第i件物品的策略（放或不放），那么就可以转化为一个只牵扯前i-1件物品的问题。如果不放第i件物品，那么问题就转化为“前i-1件物品放入容量为v的背包中”，价值为f[i-1][v]；如果放第i件物品，那么问题就转化为“前i-1件物品放入剩下的容量为v-c[i]的背包中”，此时能获得的最大价值就是f[i-1][v-c[i]]再加上通过放入第i件物品获得的价值w[i]。  \r\n\r\n以上方法的时间和空间复杂度均为O(VN)，其中时间复杂度应该已经不能再优化了，但空间复杂度却可以优化到O。\r\n\r\n先考虑上面讲的基本思路如何实现，肯定是有一个主循环i=1..N，每次算出来二维数组f[i][0..V]的所有值。那么，如果只用一个数组f[0..V]，能不能保证第i次循环结束后f[v]中表示的就是我们定义的状态f[i][v]呢？f[i][v]是由f[i-1][v]和f[i-1][v-c[i]]两个子问题递推而来，能否保证在推f[i][v]时（也即在第i次主循环中推f[v]时）能够得到f[i-1][v]和f[i-1][v-c[i]]的值呢？事实上，这要求在每次主循环中我们以v=V..0的顺序推f[v]，这样才能保证推f[v]时f[v-c[i]]保存的是状态f[i-1][v-c[i]]的值。伪代码如下：  \r\n```c\r\nfor i=1..N\r\n    for v=V..0\r\n        f[v]=max{f[v],f[v-c[i]]+w[i]};\r\n```  \r\n其中的f[v]=max{f[v],f[v-c[i]]}一句恰就相当于我们的转移方程f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]}，因为现在的f[v-c[i]]就相当于原来的f[i-1][v-c[i]]。如果将v的循环顺序从上面的逆序改成顺序的话，那么则成了f[i][v]由f[i][v-c[i]]推知，与本题意不符，但它却是另一个重要的背包问题P02最简捷的解决方案。  \r\n\r\n补充细节问题：  \r\n求最优解的背包问题题目中，事实上有两种不太相同的问法。有的题目要求“恰好装满背包”时的最优解，有的题目则并没有要求必须把背包装满。一种区别这两种问法的实现方法是在初始化的时候有所不同。  \r\n\r\n如果是第一种问法，要求恰好装满背包，那么在初始化时除了f[0]为0其它f[1..V]均设为-∞，这样就可以保证最终得到的f[N]是一种恰好装满背包的最优解。  \r\n\r\n如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将f[0..V]全部设为0。  \r\n\r\n为什么呢？可以这样理解：初始化的f数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为0的背包可能被价值为0的nothing“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，它们的值就都应该是-∞了。如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就全部为0了。  \r\n\r\n### 完全背包问题 ###\r\n有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。  \r\n基本思路：这个问题非常类似于01背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取0件、取1件、取2件……等很多种。如果仍然按照解01背包时的思路，令f[i][v]表示前i种物品恰放入一个容量为v的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程，像这样：  \r\n\r\n> f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0<=k*c[i]<=v}\r\n\r\n将01背包问题的基本思路加以改进，得到了这样一个清晰的方法。这说明01背包问题的方程的确是很重要，可以推及其它类型的背包问题。但我们还是试图改进这个复杂度。  \r\n\r\n转化为0-1背包问题求解  \r\n```c\r\nfor i=1..N\r\n    for v=0..V\r\n        f[v]=max{f[v],f[v-cost]+weight}\r\n```\r\n你会发现，这个伪代码与0-1背包问题的伪代码只有v的循环次序不同而已。为什么这样一改就可行呢？首先想想为什么P01中要按照v=V..0的逆序来循环。这是因为要保证第i次循环中的状态f[i][v]是由状态f[i-1][v-c[i]]递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第i件物品”这件策略时，依据的是一个绝无已经选入第i件物品的子结果f[i-1][v-c[i]]。而现在完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第i种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果f[i][v-c[i]]，所以就可以并且必须采用v=0..V的顺序循环。这就是这个简单的程序为何成立的道理。\r\n\r\n### 多重背包问题 ###\r\n有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。  \r\n基本思路：这题目和完全背包问题很类似。基本的方程只需将完全背包问题的方程略微一改即可，因为对于第i种物品有n[i]+1种策略：取0件，取1件……取n[i]件。令f[i][v]表示前i种物品恰放入一个容量为v的背包的最大权值，则有状态转移方程：  \r\n\r\n> f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0<=k<=n[i]}\r\n\r\n转化为0-1背包问题求解  \r\n由01背包的分析可知，01背包中允许放入的物品有重复，即01背包中如果考虑要放入的物品的重量和价格相同，不影响最终的结果，因为我们可以考虑把多重背包问题中限制数目的物品拆分成单独的一件件物品，作为01背包问题考虑。',1,'post','publish','数据结构,动态规划','编程',171,0,1,1,1),(28,'springboot博客+ssl','springboot-ssl',1526180890,1526784789,'看到[好友的博客][1]加上了小绿锁，于是有了下面的折腾。SSL的安全性在此不再赘述...\r\n\r\n### 申请证书 ###\r\n[腾讯云亚洲诚信][2]，免费的是坠吼滴！\r\n自己用`java`生成的证书浏览器会依然提示不安全。\r\n申请完后需要校验域名所有权，添加一条`dns`解析记录就ok了，具体官网都有。不得不说，校验颁发证书的速度极快呀！\r\n\r\n### springboot配置 ###\r\nspringboot由于有内嵌的tomcat服务器，所以需要做的就是在配置文件中配置**https请求**，使用代码编程配置**http请求**，并将**http请求**重定向至**https请求**  \r\n\r\n 1. 将证书文件存放于**resource**文件夹下\r\n 2. 编辑springboot配置文件关于ssl的配置  \r\n```properties\r\n#ssl\r\nserver.ssl.key-store=classpath:plover.jks    //Path to the key store that holds the SSL certificate (typically a jks file).\r\nserver.ssl.key-store-password=passwd    //Password used to access the key in the key store.\r\nserver.ssl.key-password=passwd    //Password used to access the key store.\r\nserver.ssl.key-store-type=JKS    //Type of the key store.\r\nserver.port=443    //The ssl port\r\n```\r\n 3. 编程配置http请求重定向  \r\n```java\r\npackage com.my.blog.website.config;\r\n\r\nimport org.apache.catalina.Context;\r\nimport org.apache.catalina.connector.Connector;\r\nimport org.apache.tomcat.util.descriptor.web.SecurityCollection;\r\nimport org.apache.tomcat.util.descriptor.web.SecurityConstraint;\r\nimport org.springframework.boot.context.embedded.EmbeddedServletContainerFactory;\r\nimport org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\n\r\n@Configuration\r\npublic class TomcatHttpConfig {\r\n    @Bean\r\n    public EmbeddedServletContainerFactory servletContainer() {\r\n        TomcatEmbeddedServletContainerFactory\r\n                tomcat = new TomcatEmbeddedServletContainerFactory() {\r\n\r\n            @Override\r\n            protected void\r\n            postProcessContext(Context context) {\r\n\r\n                SecurityConstraint securityConstraint = new SecurityConstraint();\r\n                securityConstraint.setUserConstraint(\"CONFIDENTIAL\");\r\n                SecurityCollection collection = new SecurityCollection();\r\n                collection.addPattern(\"/*\");\r\n                securityConstraint.addCollection(collection);\r\n                context.addConstraint(securityConstraint);\r\n            }\r\n        };\r\n        //添加连接配置，主要是http的配置信息.\r\n        tomcat.addAdditionalTomcatConnectors(initiateHttpConnector());\r\n        return tomcat;\r\n    }\r\n\r\n    /**\r\n     * 配置一个http连接信息.\r\n     * @return\r\n     */\r\n    private Connector\r\n    initiateHttpConnector() {\r\n        Connector connector = new Connector(\"org.apache.coyote.http11.Http11NioProtocol\");\r\n        connector.setScheme(\"http\");\r\n        connector.setPort(80);\r\n        connector.setSecure(false);\r\n        connector.setRedirectPort(443);\r\n        return connector;\r\n    }\r\n}\r\n```  \r\n\r\nOK，大功告成，小绿锁get！\r\n\r\n  [1]: https://inzh.me\r\n  [2]: https://buy.cloud.tencent.com/ssl?fromSource=trustasiassl',1,'post','publish','springboot,框架,Java','编程',72,0,1,1,1),(29,'计算机网络笔记','network',1527997193,1528001027,'复习计算机网络考试时自己看书整理的笔记。  \r\n\r\n## 计算机网络概述 ##\r\n![请输入图片描述][1]\r\n\r\n\r\n## 物理层 ##\r\n![请输入图片描述][2]\r\n## 数据链路层 ##\r\n![请输入图片描述][3]\r\n![请输入图片描述][4]\r\n## 网络层 ##\r\n![请输入图片描述][5]\r\n![请输入图片描述][6]\r\n## 传输层 ##\r\n![请输入图片描述][7]\r\n\r\n偷个懒...\r\n![请输入图片描述][8]\r\n![请输入图片描述][9]\r\n![请输入图片描述][10]\r\n\r\n\r\n  [1]: http://plover.space/upload/2018/06/rp3ufo9o24jb0og42uck5soqs3.jpg\r\n  [2]: http://plover.space/upload/2018/06/3ge1p9rjh6g71rdqimomcstrbv.jpg\r\n  [3]: http://plover.space/upload/2018/06/smanl83ctcgg1ov87fccvj4veu.jpg\r\n  [4]: http://plover.space/upload/2018/06/2b9ff94g3iiqsp3vf6l8t7ni1q.jpg\r\n  [5]: http://plover.space/upload/2018/06/06n6h2vla0hcept871vfquu6tt.jpg\r\n  [6]: http://plover.space/upload/2018/06/40irrlgi5iifapi11p1aeem3o5.jpg\r\n  [7]: http://plover.space/upload/2018/06/10c7mathkeipgrojp8ktmlpsik.jpg\r\n  [8]: http://plover.space/upload/2018/06/4eamrsese0hoirbboh4hahlfm3.jpg\r\n  [9]: http://plover.space/upload/2018/06/pdqvr1btgsjd1o1eoppm9tf0h8.jpg\r\n  [10]: http://plover.space/upload/2018/06/020jn9rnaij9epr7a63ie7sa97.jpg',1,'post','publish','计算机网络','笔记',83,0,1,1,1),(30,'6月的尾巴','end-of-june',1530271565,1530277315,'一个学期就这么过去了，当我写下这篇文章时离**2019**考研还有**176 天 4 时 28 分 23 秒**……\r\n\r\n## 来也匆匆，去也匆匆\r\n记得3月份去学校临要走的前一天买的中转票，到了中转站狂奔换乘，前脚上车还没坐稳列车就开动了，可以说是很幸运了2333\r\n\r\n这次回家应该是我回来的最早的一次，几门考试都安排在考试周前结束了，于是上午考完数据结构立马就跑去火车站，踏上了归家的旅途。（*临回家前一天晚上得知亲人出了点事，惴惴不安；让同学帮我代交课设报告，归心似箭*）\r\n\r\n## 学期总结\r\n过去的4个月，可以说是心态起伏很大了，在这个过程中**得到**了许多，具体来说：\r\n- 从刚做数学时候的毫无头绪，到逐渐形成了一个相对完整的知识网络\r\n- 考研英语单词过了几遍啦！考了6级，感觉这次应该能过吧o((⊙﹏⊙))o\r\n- 复习期末考试的时候，写着写着突然掌握了短期内突击应试考试的方法(〃\'▽\'〃)\r\n- 练了字，模仿[荆霄鹏](https://pan.baidu.com/s/1QATYK5cjhCjNY59hzGNcuw)大师的。\r\n- 学习了[Daily English Dictation](https://www.bilibili.com/video/av19231865)，**Shane**真的是个非常好，有耐心并热爱自己事业的老师。\r\n\r\n但令我自我认同不够的方面往往更多：\r\n- 时间利用度不够。虽然这应该是我学习时长最长的一个学期，但到6月份，却处在一个无心复习的尴尬境地。既没有心思复习考研，又没有充分的将时间利用起来复习期末考试的科目。取而代之，打了很多游戏。数学想必退化了很多吧╮(╯﹏╰）╭\r\n- 后悔之前没有把相关专业课当回事，这学期的操作系统、计算机网络、数据结构的期末复习使我受益良多（数据库也是！），加上兴起之时，我竟然翻出来上学期的计算机组成原理课本看了一遍，这算是复习了一遍**408**？短期记忆持续不了多久，但以后用到这些科目的话应该能轻松捡起来啦。\r\n- 自我认知还不够。自以为复习的蛮好的计算机网络只考了**61**分，老师说我的答案似是而非。只能说，阿华真的很严格￣へ￣。还有就是很早以前就接触的数据结构，一些知识熟练度太低了，编码技能太渣（坚持自信不用小抄，结果最后一门科目管前桌要了她的编程题小抄，我……）。\r\n- 运动量太少啦！运动量最少的一个学期，篮球没打，跑步没跑，有点感觉身体吃不消。\r\n- 还是不够淡定。情绪很多，某些事情上准备不足也是一方面原因吧。\r\n\r\n## 暑假计划\r\n本来计划和同学在学校附近租房子，但思忖再三还是回家了，在家刚呆了半天就发现不对劲，赶紧计划以下暑期计划。\r\n\r\n\r\n![计划][1]\r\n\r\n\r\n其实，准备了这么久考研，终于明白了何为放下。\r\n首先，放下功利。兴趣才是长期驱动力，急功近利不如稳扎稳打来的实在。\r\n再者，放下过往。不要把自己束缚在过去的执念之中，选择方向只顾风雨兼程。\r\n最重要的，放平心态。胜不骄败不馁。\r\n\r\n希望假期结束，自己能淡定的面对下学期的小挑战吧。\r\n\r\n\r\n  [1]: http://plover.space//upload/2018/06/6m24im70aohajprtg1g3s8c08v.PNG',1,'post','publish','思索','生活',34,0,1,1,1);
/*!40000 ALTER TABLE `t_contents` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_logs`
--

DROP TABLE IF EXISTS `t_logs`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `t_logs` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `action` varchar(100) DEFAULT NULL,
  `data` varchar(2000) DEFAULT NULL,
  `author_id` int(10) DEFAULT NULL,
  `ip` varchar(20) DEFAULT NULL,
  `created` int(10) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=114 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_logs`
--

LOCK TABLES `t_logs` WRITE;
/*!40000 ALTER TABLE `t_logs` DISABLE KEYS */;
INSERT INTO `t_logs` VALUES (1,'登录后台',NULL,1,'0:0:0:0:0:0:0:1',1496815277),(2,'登录后台',NULL,1,'0:0:0:0:0:0:0:1',1496815280),(3,'登录后台',NULL,1,'0:0:0:0:0:0:0:1',1496815318),(4,'登录后台',NULL,1,'0:0:0:0:0:0:0:1',1496815398),(5,'登录后台',NULL,1,'0:0:0:0:0:0:0:1',1496815482),(6,'登录后台',NULL,1,'0:0:0:0:0:0:0:1',1496815492),(7,'保存系统设置','{\"site_keywords\":\"Blog\",\"site_description\":\"SpringBoot+Mybatis+thymeleaf 搭建的 Java 博客系统\",\"site_title\":\"Blog\",\"site_theme\":\"default\",\"allow_install\":\"\"}',1,'0:0:0:0:0:0:0:1',1496815955),(8,'保存系统设置','{\"site_keywords\":\"Blog\",\"site_description\":\"SpringBoot+Mybatis+thymeleaf 搭建的 Java 博客系统\",\"site_title\":\"Blog\",\"site_theme\":\"default\",\"allow_install\":\"\"}',1,'0:0:0:0:0:0:0:1',1496815964),(9,'登录后台',NULL,1,'0:0:0:0:0:0:0:1',1496989015),(10,'登录后台',NULL,1,'0:0:0:0:0:0:0:1',1496989366),(11,'登录后台',NULL,1,'0:0:0:0:0:0:0:1',1497317863),(12,'保存系统设置','{\"social_zhihu\":\"https://www.zhihu.com/people/tian-zhisheng/activities\",\"social_github\":\"https://github.com/zhisheng17\",\"social_twitter\":\"\",\"social_weibo\":\"\"}',1,'0:0:0:0:0:0:0:1',1497318696),(13,'修改个人信息','{\"uid\":1,\"email\":\"1041218129@qq.com\",\"screenName\":\"admin\"}',1,'0:0:0:0:0:0:0:1',1497319220),(14,'登录后台',NULL,1,'0:0:0:0:0:0:0:1',1497319856),(15,'登录后台',NULL,1,'127.0.0.1',1497321561),(16,'登录后台',NULL,1,'127.0.0.1',1497322738),(17,'登录后台',NULL,1,'0:0:0:0:0:0:0:1',1497323446),(18,'删除文章','2',1,'0:0:0:0:0:0:0:1',1497323495),(19,'登录后台',NULL,1,'0:0:0:0:0:0:0:1',1497427641),(20,'登录后台',NULL,1,'0:0:0:0:0:0:0:1',1497428250),(21,'登录后台',NULL,1,'0:0:0:0:0:0:0:1',1497428290),(22,'登录后台',NULL,1,'0:0:0:0:0:0:0:1',1497428556),(23,'登录后台',NULL,1,'0:0:0:0:0:0:0:1',1497674581),(24,'修改个人信息','{\"uid\":1,\"email\":\"1041218129@qq.com\",\"screenName\":\"admin\"}',1,'0:0:0:0:0:0:0:1',1497674690),(25,'登录后台',NULL,1,'0:0:0:0:0:0:0:1',1497676623),(26,'登录后台',NULL,1,'0:0:0:0:0:0:0:1',1497683817),(27,'登录后台',NULL,1,'0:0:0:0:0:0:0:1',1497685128),(28,'登录后台',NULL,1,'127.0.0.1',1497689032),(29,'登录后台',NULL,1,'121.28.97.248',1514359242),(30,'删除文章','6',1,'121.28.97.248',1514359253),(31,'删除文章','5',1,'121.28.97.248',1514359256),(32,'删除文章','4',1,'121.28.97.248',1514359259),(33,'删除文章','3',1,'121.28.97.248',1514359264),(34,'保存系统设置','{\"site_keywords\":\"Blog\",\"site_description\":\"杂谈琐碎，闲言碎语\",\"site_title\":\"Plover.space\",\"site_theme\":\"default\",\"allow_install\":\"\"}',1,'121.28.97.248',1514359410),(35,'保存系统设置','{\"social_zhihu\":\"\",\"social_github\":\"\",\"social_twitter\":\"\",\"social_weibo\":\"\"}',1,'121.28.97.248',1514359417),(36,'删除文章','/upload/2017/06/t93vgdj6o8irgo87ds56u0ou0s.jpeg',1,'121.28.97.248',1514359428),(37,'修改个人信息','{\"uid\":1,\"email\":\"1002684417@qq.com\",\"screenName\":\"p9j7\"}',1,'121.28.97.248',1514359506),(38,'登录后台',NULL,1,'121.28.97.248',1514360179),(39,'修改密码',NULL,1,'121.28.97.248',1514360229),(40,'登录后台',NULL,1,'121.28.97.248',1514362114),(41,'登录后台',NULL,1,'121.28.97.248',1514363607),(42,'登录后台',NULL,1,'121.28.97.248',1514363607),(43,'保存系统设置','{\"social_zhihu\":\"\",\"social_github\":\"https://github.com/P9J7\",\"social_twitter\":\"\",\"social_weibo\":\"\"}',1,'121.28.97.248',1514364420),(44,'登录后台',NULL,1,'121.28.97.248',1514365760),(45,'登录后台',NULL,1,'121.28.97.248',1514366657),(46,'登录后台',NULL,1,'121.28.97.248',1514366658),(47,'保存系统设置','{\"site_keywords\":\"Blog\",\"site_description\":\"p9j7的个人博客\",\"site_title\":\"Plover.space\",\"site_theme\":\"default\",\"allow_install\":\"\"}',1,'121.28.97.248',1514367070),(48,'删除文章','11',1,'121.28.97.248',1514367253),(49,'登录后台',NULL,1,'45.77.169.215',1514368087),(50,'登录后台',NULL,1,'45.77.169.215',1514368088),(51,'登录后台',NULL,1,'45.77.169.215',1514368089),(52,'登录后台',NULL,1,'121.28.97.248',1514441008),(53,'登录后台',NULL,1,'222.223.188.168',1514531395),(54,'删除文章','/upload/2017/12/qrpduffdqug69rbmq9372mgru7.jpg',1,'222.223.188.168',1514531897),(55,'登录后台',NULL,1,'121.28.97.248',1514624345),(56,'登录后台',NULL,1,'121.193.210.121',1514633118),(57,'登录后台',NULL,1,'121.28.97.248',1514640988),(58,'删除文章','/upload/2017/12/1a0p8bh5mqitnonv4vcsvjf8bg.png',1,'121.28.97.248',1514641344),(59,'登录后台',NULL,1,'45.77.169.215',1514801744),(60,'登录后台',NULL,1,'45.77.169.215',1515128478),(61,'登录后台',NULL,1,'121.193.210.121',1515134782),(62,'登录后台',NULL,1,'121.193.210.121',1515138378),(63,'登录后台',NULL,1,'121.28.97.248',1515140934),(64,'登录后台',NULL,1,'110.249.243.78',1515144359),(65,'登录后台',NULL,1,'198.13.43.234',1515166136),(66,'登录后台',NULL,1,'198.13.43.234',1515166137),(67,'登录后台',NULL,1,'198.13.43.234',1515167293),(68,'登录后台',NULL,1,'121.28.97.248',1515397296),(69,'登录后台',NULL,1,'121.28.97.248',1515401185),(70,'登录后台',NULL,1,'121.193.210.121',1515549472),(71,'登录后台',NULL,1,'121.28.97.248',1515553122),(72,'登录后台',NULL,1,'110.249.242.207',1515769551),(73,'登录后台',NULL,1,'121.28.97.248',1515809618),(74,'登录后台',NULL,1,'121.28.97.248',1515812308),(75,'登录后台',NULL,1,'121.28.97.248',1515814443),(76,'登录后台',NULL,1,'222.223.188.168',1515833143),(77,'登录后台',NULL,1,'121.28.97.248',1516498389),(78,'删除页面','13',1,'121.28.97.248',1516500394),(79,'登录后台',NULL,1,'111.23.59.109',1516868284),(80,'登录后台',NULL,1,'111.23.59.109',1517222593),(81,'登录后台',NULL,1,'111.22.144.133',1517645729),(82,'登录后台',NULL,1,'111.22.143.228',1518436857),(83,'登录后台',NULL,1,'111.23.197.69',1519637483),(84,'登录后台',NULL,1,'111.23.197.69',1519640094),(85,'登录后台',NULL,1,'198.13.43.234',1521789610),(86,'登录后台',NULL,1,'121.28.97.242',1526022884),(87,'登录后台',NULL,1,'198.13.43.234',1526025135),(88,'删除文章','/upload/2018/05/rqb5qbrcnkj0cphlftntje8lud.doc',1,'198.13.43.234',1526025220),(89,'登录后台',NULL,1,'198.13.43.234',1526091539),(90,'登录后台',NULL,1,'198.13.43.234',1526096795),(91,'登录后台',NULL,1,'198.13.43.234',1526099255),(92,'删除文章','/upload/2018/05/p9teuokqrgijsqkadjfn7pc3dl.png',1,'198.13.43.234',1526104418),(93,'登录后台',NULL,1,'198.13.43.234',1526111592),(94,'登录后台',NULL,1,'198.13.43.234',1526179794),(95,'登录后台',NULL,1,'198.13.43.234',1526212479),(96,'登录后台',NULL,1,'198.13.43.234',1526783730),(97,'登录后台',NULL,1,'110.249.242.164',1527991833),(98,'登录后台',NULL,1,'198.13.43.234',1527993047),(99,'删除文章','/upload/2018/06/vtc50it1uqj9cp74bb6aotvlu5.jpg',1,'198.13.43.234',1527995160),(100,'删除文章','/upload/2018/06/6m8ls51us6hlpr38ksa0pg3j61.jpg',1,'198.13.43.234',1527995166),(101,'删除文章','/upload/2018/06/uta4q7saogg3lqr9fbu00t6hei.jpg',1,'198.13.43.234',1527995268),(102,'删除文章','/upload/2018/06/u51pcovrvejkup9oaf16gc6eug.jpg',1,'198.13.43.234',1527995275),(103,'删除文章','/upload/2018/06/oeo1a0trakiiio6lis5vjmhdsl.jpg',1,'198.13.43.234',1527995282),(104,'删除文章','/upload/2018/06/ufpqrf9na6hnsqj7o7u4sfv494.jpg',1,'198.13.43.234',1527995288),(105,'删除文章','/upload/2018/06/or770d2l06hn7rhqp75a39inlc.jpg',1,'110.249.242.164',1527995308),(106,'登录后台',NULL,1,'198.13.43.234',1527995759),(107,'删除文章','/upload/2018/06/p8s7s1cc30ishpfak4kh490c7h.jpg',1,'198.13.43.234',1527995768),(108,'删除文章','/upload/2018/06/0b64dheapohskq39o98uqihpam.jpg',1,'198.13.43.234',1527996127),(109,'登录后台',NULL,1,'198.13.43.234',1528000492),(110,'登录后台',NULL,1,'110.249.245.159',1529374961),(111,'登录后台',NULL,1,'36.157.181.98',1530271466),(112,'登录后台',NULL,1,'198.13.43.234',1530276966),(113,'删除文章','/upload/2018/06/6j6oh3ddqqh6trekvst6mket2j.png',1,'198.13.43.234',1530277247);
/*!40000 ALTER TABLE `t_logs` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_metas`
--

DROP TABLE IF EXISTS `t_metas`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `t_metas` (
  `mid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(200) DEFAULT NULL,
  `slug` varchar(200) DEFAULT NULL,
  `type` varchar(32) NOT NULL DEFAULT '',
  `description` varchar(200) DEFAULT NULL,
  `sort` int(10) unsigned DEFAULT '0',
  `parent` int(10) unsigned DEFAULT '0',
  PRIMARY KEY (`mid`),
  KEY `slug` (`slug`)
) ENGINE=InnoDB AUTO_INCREMENT=65 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_metas`
--

LOCK TABLES `t_metas` WRITE;
/*!40000 ALTER TABLE `t_metas` DISABLE KEYS */;
INSERT INTO `t_metas` VALUES (21,'生活',NULL,'category',NULL,0,0),(22,'碎语','碎语','tag',NULL,0,0),(25,'默认分类','默认分类','category',NULL,0,0),(26,'编程',NULL,'category',NULL,0,0),(27,'思索','思索','tag',NULL,0,0),(30,'多线程','多线程','tag',NULL,0,0),(31,'Java','Java','tag',NULL,0,0),(32,'框架','框架','tag',NULL,0,0),(33,'大数据','大数据','tag',NULL,0,0),(35,'Elasticsearch','Elasticsearch','tag',NULL,0,0),(36,'实用指南','实用指南','tag',NULL,0,0),(37,'阮一峰的网络日志','http://www.ruanyifeng.com/blog/','link','',99,0),(38,'BYVoid','https://www.byvoid.com/zhs/','link','',2,0),(40,'IT草根','http://codepub.cn/','link','',50,0),(41,'纯洁的微笑','http://www.ityouknow.com/','link','',70,0),(42,'Freud\'s Blog','http://www.hifreud.com/','link','',1,0),(43,'Chenfan Blog','http://jcf94.com/','link','',11,0),(48,'In Life','https://forbetty.com/','link','',60,0),(49,'丁亮的个人博客','http://88250.b3log.org/','link','',49,0),(50,'Spring','Spring','tag',NULL,0,0),(51,'SpringMVC','SpringMVC','tag',NULL,0,0),(52,'Mybatis','Mybatis','tag',NULL,0,0),(53,'手记',NULL,'category',NULL,0,0),(54,'数据结构','数据结构','tag',NULL,0,0),(55,'排序','排序','tag',NULL,0,0),(56,'柳婼 の blog','https://www.liuchuo.net/','link','',77,0),(57,'树','树','tag',NULL,0,0),(58,'图','图','tag',NULL,0,0),(59,'查找','查找','tag',NULL,0,0),(60,'串','串','tag',NULL,0,0),(61,'动态规划','动态规划','tag',NULL,0,0),(62,'springboot','springboot','tag',NULL,0,0),(63,'笔记',NULL,'category',NULL,0,0),(64,'计算机网络','计算机网络','tag',NULL,0,0);
/*!40000 ALTER TABLE `t_metas` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_options`
--

DROP TABLE IF EXISTS `t_options`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `t_options` (
  `name` varchar(32) NOT NULL DEFAULT '',
  `value` varchar(1000) DEFAULT '',
  `description` varchar(200) DEFAULT NULL,
  PRIMARY KEY (`name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_options`
--

LOCK TABLES `t_options` WRITE;
/*!40000 ALTER TABLE `t_options` DISABLE KEYS */;
INSERT INTO `t_options` VALUES ('allow_install','',''),('site_description','p9j7的个人博客',NULL),('site_keywords','Blog',NULL),('site_theme','default',NULL),('site_title','Plover.space',''),('social_github','https://github.com/P9J7',NULL),('social_twitter','',NULL),('social_weibo','',NULL),('social_zhihu','',NULL);
/*!40000 ALTER TABLE `t_options` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_relationships`
--

DROP TABLE IF EXISTS `t_relationships`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `t_relationships` (
  `cid` int(10) unsigned NOT NULL,
  `mid` int(10) unsigned NOT NULL,
  PRIMARY KEY (`cid`,`mid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_relationships`
--

LOCK TABLES `t_relationships` WRITE;
/*!40000 ALTER TABLE `t_relationships` DISABLE KEYS */;
INSERT INTO `t_relationships` VALUES (7,21),(7,22),(12,21),(12,26),(12,27),(14,26),(14,30),(14,31),(15,26),(15,31),(15,32),(16,26),(16,31),(16,33),(16,35),(17,26),(17,31),(17,36),(18,26),(18,31),(18,32),(18,36),(18,50),(18,51),(18,52),(19,21),(19,27),(20,27),(20,53),(21,26),(21,54),(21,55),(22,26),(22,54),(22,57),(23,26),(23,54),(23,58),(24,26),(24,54),(24,59),(25,26),(25,54),(25,57),(26,26),(26,54),(26,59),(26,60),(27,26),(27,54),(27,61),(28,26),(28,31),(28,32),(28,62),(29,63),(29,64),(30,21),(30,27);
/*!40000 ALTER TABLE `t_relationships` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_users`
--

DROP TABLE IF EXISTS `t_users`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `t_users` (
  `uid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `username` varchar(32) DEFAULT NULL,
  `password` varchar(64) DEFAULT NULL,
  `email` varchar(200) DEFAULT NULL,
  `home_url` varchar(200) DEFAULT NULL,
  `screen_name` varchar(32) DEFAULT NULL,
  `created` int(10) unsigned DEFAULT '0',
  `activated` int(10) unsigned DEFAULT '0',
  `logged` int(10) unsigned DEFAULT '0',
  `group_name` varchar(16) DEFAULT 'visitor',
  PRIMARY KEY (`uid`),
  UNIQUE KEY `name` (`username`),
  UNIQUE KEY `mail` (`email`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_users`
--

LOCK TABLES `t_users` WRITE;
/*!40000 ALTER TABLE `t_users` DISABLE KEYS */;
INSERT INTO `t_users` VALUES (1,'admin','410d069a7c669937609d1223dd60879e','1002684417@qq.com',NULL,'p9j7',1490756162,0,0,'visitor');
/*!40000 ALTER TABLE `t_users` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2018-07-07 12:23:34
